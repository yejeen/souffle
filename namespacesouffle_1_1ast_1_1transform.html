<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>souffle: souffle::ast::transform Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">souffle
   &#160;<span id="projectnumber">8dcff60</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesouffle.html">souffle</a></li><li class="navelem"><a class="el" href="namespacesouffle_1_1ast.html">ast</a></li><li class="navelem"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html">transform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">souffle::ast::transform Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesouffle_1_1ast_1_1transform_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_add_nullaries_to_atomless_aggregates_transformer.html">AddNullariesToAtomlessAggregatesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to add artificial nullary atom (+Tautology()) to aggregate bodies that have no atoms.  <a href="classsouffle_1_1ast_1_1transform_1_1_add_nullaries_to_atomless_aggregates_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_a_d_tto_records_transformer.html">ADTtoRecordsTransformer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_component_checker.html">ComponentChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_component_instantiation_transformer.html">ComponentInstantiationTransformer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_conditional_transformer.html">ConditionalTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a> that executes a sub-transformer iff a condition holds.  <a href="classsouffle_1_1ast_1_1transform_1_1_conditional_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_debug_reporter.html">DebugReporter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass which wraps another transformation pass and generates a debug report section for the stage after applying the wrapped transformer, and adds it to the translation unit's debug report.  <a href="classsouffle_1_1ast_1_1transform_1_1_debug_reporter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_execution_plan_checker.html">ExecutionPlanChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_fixpoint_transformer.html">FixpointTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a> that repeatedly executes a sub-transformer until no changes are made.  <a href="classsouffle_1_1ast_1_1transform_1_1_fixpoint_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_fold_anonymous_records.html">FoldAnonymousRecords</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass that removes (binary) constraints on the anonymous records.  <a href="classsouffle_1_1ast_1_1transform_1_1_fold_anonymous_records.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_grounded_terms_checker.html">GroundedTermsChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_inline_relations_transformer.html">InlineRelationsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to inline marked relations.  <a href="classsouffle_1_1ast_1_1transform_1_1_inline_relations_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_i_o_attributes_transformer.html">IOAttributesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to set attribute names and types in IO operations.  <a href="classsouffle_1_1ast_1_1transform_1_1_i_o_attributes_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_i_o_defaults_transformer.html">IODefaultsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to set defaults for IO operations.  <a href="classsouffle_1_1ast_1_1transform_1_1_i_o_defaults_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer.html">MagicSetTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic Set Transformation.  <a href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html">MaterializeAggregationQueriesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to create artificial relations for bodies of aggregation functions consisting of more than a single atom.  <a href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_singleton_aggregation_transformer.html">MaterializeSingletonAggregationTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces literals containing single-valued aggregates with a synthesised relation.  <a href="classsouffle_1_1ast_1_1transform_1_1_materialize_singleton_aggregation_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_meta_transformer.html">MetaTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a> that coordinates other sub-transformations.  <a href="classsouffle_1_1ast_1_1transform_1_1_meta_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_minimise_program_transformer.html">MinimiseProgramTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove equivalent rules.  <a href="classsouffle_1_1ast_1_1transform_1_1_minimise_program_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_name_unnamed_variables_transformer.html">NameUnnamedVariablesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to replace unnamed variables with singletons.  <a href="classsouffle_1_1ast_1_1transform_1_1_name_unnamed_variables_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_normalise_constraints_transformer.html">NormaliseConstraintsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to normalise constraints.  <a href="classsouffle_1_1ast_1_1transform_1_1_normalise_constraints_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_null_transformer.html">NullTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a> that does absolutely nothing.  <a href="classsouffle_1_1ast_1_1transform_1_1_null_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_partition_body_literals_transformer.html">PartitionBodyLiteralsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to move literals into new clauses if they are independent of remaining literals.  <a href="classsouffle_1_1ast_1_1transform_1_1_partition_body_literals_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_pipeline_transformer.html">PipelineTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a> that holds an arbitrary number of sub-transformations.  <a href="classsouffle_1_1ast_1_1transform_1_1_pipeline_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_polymorphic_objects_transformer.html">PolymorphicObjectsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to determine instances of polymorphic object objects = Functors (plus, minus...) ∪ binary constraints (&gt;, ≥ ...) ∪ aggregation ∪ numeric constants.  <a href="classsouffle_1_1ast_1_1transform_1_1_polymorphic_objects_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_pragma_checker.html">PragmaChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_provenance_transformer.html">ProvenanceTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to add provenance information.  <a href="classsouffle_1_1ast_1_1transform_1_1_provenance_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_reduce_existentials_transformer.html">ReduceExistentialsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to reduce unnecessary computation for relations that only appear in the form A(_,...,_).  <a href="classsouffle_1_1ast_1_1transform_1_1_reduce_existentials_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_remove_boolean_constraints_transformer.html">RemoveBooleanConstraintsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove constant boolean constraints Should be called after any transformation that may generate boolean constraints.  <a href="classsouffle_1_1ast_1_1transform_1_1_remove_boolean_constraints_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_remove_empty_relations_transformer.html">RemoveEmptyRelationsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove all empty relations and rules that use empty relations.  <a href="classsouffle_1_1ast_1_1transform_1_1_remove_empty_relations_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_remove_redundant_relations_transformer.html">RemoveRedundantRelationsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove relations which are redundant (do not contribute to output).  <a href="classsouffle_1_1ast_1_1transform_1_1_remove_redundant_relations_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_remove_redundant_sums_transformer.html">RemoveRedundantSumsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove expressions of the form sum k : { ...  <a href="classsouffle_1_1ast_1_1transform_1_1_remove_redundant_sums_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_remove_relation_copies_transformer.html">RemoveRelationCopiesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to replaces copy of relations by their origin.  <a href="classsouffle_1_1ast_1_1transform_1_1_remove_relation_copies_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_remove_typecasts_transformer.html">RemoveTypecastsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation to remove typecasts.  <a href="classsouffle_1_1ast_1_1transform_1_1_remove_typecasts_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_reorder_literals_transformer.html">ReorderLiteralsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to reorder body literals.  <a href="classsouffle_1_1ast_1_1transform_1_1_reorder_literals_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_replace_singleton_variables_transformer.html">ReplaceSingletonVariablesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to replace singleton variables with unnamed variables.  <a href="classsouffle_1_1ast_1_1transform_1_1_replace_singleton_variables_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_resolve_aliases_transformer.html">ResolveAliasesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to eliminate grounded aliases.  <a href="classsouffle_1_1ast_1_1transform_1_1_resolve_aliases_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_resolve_anonymous_record_aliases_transformer.html">ResolveAnonymousRecordAliasesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a> resolving aliases for anonymous records.  <a href="classsouffle_1_1ast_1_1transform_1_1_resolve_anonymous_record_aliases_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_semantic_checker.html">SemanticChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ast_1_1transform_1_1_semantic_checker_impl.html">SemanticCheckerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_type_checker.html">TypeChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_unique_aggregation_variables_transformer.html">UniqueAggregationVariablesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to rename aggregation variables to make them unique.  <a href="classsouffle_1_1ast_1_1transform_1_1_unique_aggregation_variables_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_user_defined_functors_transformer.html">UserDefinedFunctorsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation that passes the type information from user functors declaration to functors instances.  <a href="classsouffle_1_1ast_1_1transform_1_1_user_defined_functors_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_while_transformer.html">WhileTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">Transformer</a> that repeatedly executes a sub-transformer while a condition is met.  <a href="classsouffle_1_1ast_1_1transform_1_1_while_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7d908952faae4b89b6b4a4118c6e435d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_adorn_database_transformer.html">MagicSetTransformer::AdornDatabaseTransformer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a7d908952faae4b89b6b4a4118c6e435d">AdornDatabaseTransformer</a></td></tr>
<tr class="separator:a7d908952faae4b89b6b4a4118c6e435d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8795a39fde0645ac01065db01c6de62e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_label_database_transformer.html">MagicSetTransformer::LabelDatabaseTransformer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a8795a39fde0645ac01065db01c6de62e">LabelDatabaseTransformer</a></td></tr>
<tr class="separator:a8795a39fde0645ac01065db01c6de62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f36c585649d3b5d04c9564d46ef55d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_magic_set_core_transformer.html">MagicSetTransformer::MagicSetCoreTransformer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a85f36c585649d3b5d04c9564d46ef55d">MagicSetCoreTransformer</a></td></tr>
<tr class="separator:a85f36c585649d3b5d04c9564d46ef55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ba78fff322bffad406b1dcc5b4a0de"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_label_database_transformer_1_1_negative_labelling_transformer.html">MagicSetTransformer::LabelDatabaseTransformer::NegativeLabellingTransformer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#ae5ba78fff322bffad406b1dcc5b4a0de">NegativeLabellingTransformer</a></td></tr>
<tr class="separator:ae5ba78fff322bffad406b1dcc5b4a0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1587e70b148038ae63c0c0350389498"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_normalise_database_transformer.html">MagicSetTransformer::NormaliseDatabaseTransformer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#af1587e70b148038ae63c0c0350389498">NormaliseDatabaseTransformer</a></td></tr>
<tr class="separator:af1587e70b148038ae63c0c0350389498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7354a99934648484ba1640209894d9a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_label_database_transformer_1_1_positive_labelling_transformer.html">MagicSetTransformer::LabelDatabaseTransformer::PositiveLabellingTransformer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#ad7354a99934648484ba1640209894d9a">PositiveLabellingTransformer</a></td></tr>
<tr class="separator:ad7354a99934648484ba1640209894d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac08b034edc612cbd02a263082b1bbc46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#ac08b034edc612cbd02a263082b1bbc46">combineAggregators</a> (std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> *&gt; aggrs, std::string fun)</td></tr>
<tr class="separator:ac08b034edc612cbd02a263082b1bbc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146c65e4e8a4429da50a66c746744e58"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a146c65e4e8a4429da50a66c746744e58">combineNegatedLiterals</a> (std::vector&lt; std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> *&gt;&gt; litGroups)</td></tr>
<tr class="memdesc:a146c65e4e8a4429da50a66c746744e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negated version of a disjunction of conjunctions.  <a href="#a146c65e4e8a4429da50a66c746744e58">More...</a><br /></td></tr>
<tr class="separator:a146c65e4e8a4429da50a66c746744e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2b2e6f9ed8feb3adfbfbfe43b96dda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#adc2b2e6f9ed8feb3adfbfbfe43b96dda">containsInlinedAtom</a> (const <a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;clause)</td></tr>
<tr class="memdesc:adc2b2e6f9ed8feb3adfbfbfe43b96dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given clause contains an atom that should be inlined.  <a href="#adc2b2e6f9ed8feb3adfbfbfe43b96dda">More...</a><br /></td></tr>
<tr class="separator:adc2b2e6f9ed8feb3adfbfbfe43b96dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748f4a8900f05d9cd286c6d04b82ba49"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_qualified_name.html">QualifiedName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a748f4a8900f05d9cd286c6d04b82ba49">findInlineCycle</a> (const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_precedence_graph_analysis.html">PrecedenceGraphAnalysis</a> &amp;precedenceGraph, std::map&lt; const <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> *, const <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> *&gt; &amp;origins, const <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> *current, <a class="el" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a> &amp;unvisited, <a class="el" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a> &amp;visiting, <a class="el" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a> &amp;visited)</td></tr>
<tr class="memdesc:a748f4a8900f05d9cd286c6d04b82ba49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a cycle consisting entirely of inlined relations.  <a href="#a748f4a8900f05d9cd286c6d04b82ba49">More...</a><br /></td></tr>
<tr class="separator:a748f4a8900f05d9cd286c6d04b82ba49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7455cc2262cc907c15e6124ac6588a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a8a7455cc2262cc907c15e6124ac6588a">formNegatedLiterals</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, <a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *atom)</td></tr>
<tr class="memdesc:a8a7455cc2262cc907c15e6124ac6588a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the bodies that will replace the negation of a given inlined atom.  <a href="#a8a7455cc2262cc907c15e6124ac6588a">More...</a><br /></td></tr>
<tr class="separator:a8a7455cc2262cc907c15e6124ac6588a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78e04494a4e67eb9ae63a399c99d92f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt; <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, const <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *arg)</td></tr>
<tr class="memdesc:ac78e04494a4e67eb9ae63a399c99d92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of arguments that should replace the given argument after one step of inlining.  <a href="#ac78e04494a4e67eb9ae63a399c99d92f">More...</a><br /></td></tr>
<tr class="separator:ac78e04494a4e67eb9ae63a399c99d92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbf430b3cb758d9345bb1ba0dd17efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt; <a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd">getInlinedAtom</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, <a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> &amp;atom)</td></tr>
<tr class="memdesc:addbf430b3cb758d9345bb1ba0dd17efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of atoms that should replace the given atom after one step of inlining.  <a href="#addbf430b3cb758d9345bb1ba0dd17efd">More...</a><br /></td></tr>
<tr class="separator:addbf430b3cb758d9345bb1ba0dd17efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0249ff1a6616f955f319df5ffdfaae41"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a0249ff1a6616f955f319df5ffdfaae41">getInlinedClause</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;clause)</td></tr>
<tr class="memdesc:a0249ff1a6616f955f319df5ffdfaae41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of clauses that should replace the given clause after one step of inlining.  <a href="#a0249ff1a6616f955f319df5ffdfaae41">More...</a><br /></td></tr>
<tr class="separator:a0249ff1a6616f955f319df5ffdfaae41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d908235c9c6d168bdfb2098b55090e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt; std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e">getInlinedLiteral</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> *lit)</td></tr>
<tr class="memdesc:a60d908235c9c6d168bdfb2098b55090e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to perform a single step of inlining on the given literal.  <a href="#a60d908235c9c6d168bdfb2098b55090e">More...</a><br /></td></tr>
<tr class="separator:a60d908235c9c6d168bdfb2098b55090e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce47150ce3942c816dc5d8286f3ee23"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> * &gt;, std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_binary_constraint.html">BinaryConstraint</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23">inlineBodyLiterals</a> (<a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *atom, <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> *atomInlineClause)</td></tr>
<tr class="memdesc:a3ce47150ce3942c816dc5d8286f3ee23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlines the given atom based on a given clause.  <a href="#a3ce47150ce3942c816dc5d8286f3ee23">More...</a><br /></td></tr>
<tr class="separator:a3ce47150ce3942c816dc5d8286f3ee23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357d4c2dfac82f7f140b6b03b00d3a2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#a767cede450719b5b1633f12b038c7d61">Own</a>&lt; <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a357d4c2dfac82f7f140b6b03b00d3a2c">makeInfoRelation</a> (<a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;originalClause, size_t originalClauseNum, <a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;translationUnit)</td></tr>
<tr class="separator:a357d4c2dfac82f7f140b6b03b00d3a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae013df7b43e604d0cbe81322c8a11dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1_qualified_name.html">QualifiedName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#aae013df7b43e604d0cbe81322c8a11dc">makeRelationName</a> (const <a class="el" href="classsouffle_1_1ast_1_1_qualified_name.html">QualifiedName</a> &amp;orig, const std::string &amp;type, int num=-1)</td></tr>
<tr class="memdesc:aae013df7b43e604d0cbe81322c8a11dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions.  <a href="#aae013df7b43e604d0cbe81322c8a11dc">More...</a><br /></td></tr>
<tr class="separator:aae013df7b43e604d0cbe81322c8a11dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fa526d9f8958b3b90d30e7b3502a1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#aa3fa526d9f8958b3b90d30e7b3502a1f">nameInlinedUnderscores</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program)</td></tr>
<tr class="memdesc:aa3fa526d9f8958b3b90d30e7b3502a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all underscores in all atoms of inlined relations.  <a href="#aa3fa526d9f8958b3b90d30e7b3502a1f">More...</a><br /></td></tr>
<tr class="separator:aa3fa526d9f8958b3b90d30e7b3502a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940bd55ad10e760454fb7af87c1c130d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d">negateLiteral</a> (<a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> *lit)</td></tr>
<tr class="memdesc:a940bd55ad10e760454fb7af87c1c130d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negated version of a given literal.  <a href="#a940bd55ad10e760454fb7af87c1c130d">More...</a><br /></td></tr>
<tr class="separator:a940bd55ad10e760454fb7af87c1c130d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe651d178e7c685164a511e9646ca475"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#abe651d178e7c685164a511e9646ca475">normaliseInlinedHeads</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program)</td></tr>
<tr class="memdesc:abe651d178e7c685164a511e9646ca475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace constants in the head of inlined clauses with (constrained) variables.  <a href="#abe651d178e7c685164a511e9646ca475">More...</a><br /></td></tr>
<tr class="separator:abe651d178e7c685164a511e9646ca475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0f3b772710ab151915d04c2538070e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#aef0f3b772710ab151915d04c2538070e">reduceSubstitution</a> (std::vector&lt; std::pair&lt; <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *, <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *&gt;&gt; &amp;sub)</td></tr>
<tr class="memdesc:aef0f3b772710ab151915d04c2538070e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces a vector of substitutions.  <a href="#aef0f3b772710ab151915d04c2538070e">More...</a><br /></td></tr>
<tr class="separator:aef0f3b772710ab151915d04c2538070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1211fcf1fa30273559973f585502c936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a1211fcf1fa30273559973f585502c936">renameVariables</a> (<a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *arg)</td></tr>
<tr class="memdesc:a1211fcf1fa30273559973f585502c936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames all variables in a given argument uniquely.  <a href="#a1211fcf1fa30273559973f585502c936">More...</a><br /></td></tr>
<tr class="separator:a1211fcf1fa30273559973f585502c936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b86d43c262e724277436f7f829a4fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a00b86d43c262e724277436f7f829a4fb">transformEqrelRelation</a> (<a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;program, <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> &amp;rel)</td></tr>
<tr class="memdesc:a00b86d43c262e724277436f7f829a4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform eqrel relations to explicitly define equivalence relations.  <a href="#a00b86d43c262e724277436f7f829a4fb">More...</a><br /></td></tr>
<tr class="separator:a00b86d43c262e724277436f7f829a4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef7394d84d020c597cb916fa67ff8ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt; std::pair&lt; <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *, <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a4ef7394d84d020c597cb916fa67ff8ed">unifyAtoms</a> (<a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *first, <a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *second)</td></tr>
<tr class="memdesc:a4ef7394d84d020c597cb916fa67ff8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nullable vector of substitutions needed to unify the two given atoms.  <a href="#a4ef7394d84d020c597cb916fa67ff8ed">More...</a><br /></td></tr>
<tr class="separator:a4ef7394d84d020c597cb916fa67ff8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa9731f3b631defab0a7f237a9f1d19"><td class="memItemLeft" align="right" valign="top">static const std::vector&lt; <a class="el" href="classsouffle_1_1_src_location.html">SrcLocation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html#adaa9731f3b631defab0a7f237a9f1d19">usesInvalidWitness</a> (<a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;tu, const std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> *&gt; &amp;literals, const std::set&lt; <a class="el" href="namespacesouffle.html#a767cede450719b5b1633f12b038c7d61">Own</a>&lt; <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> &gt;&gt; &amp;groundedArguments)</td></tr>
<tr class="separator:adaa9731f3b631defab0a7f237a9f1d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a7d908952faae4b89b6b4a4118c6e435d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d908952faae4b89b6b4a4118c6e435d">&#9670;&nbsp;</a></span>AdornDatabaseTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_adorn_database_transformer.html">MagicSetTransformer::AdornDatabaseTransformer</a> <a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a7d908952faae4b89b6b4a4118c6e435d">souffle::ast::transform::AdornDatabaseTransformer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00054">54</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

</div>
</div>
<a id="a8795a39fde0645ac01065db01c6de62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8795a39fde0645ac01065db01c6de62e">&#9670;&nbsp;</a></span>LabelDatabaseTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_label_database_transformer.html">MagicSetTransformer::LabelDatabaseTransformer</a> <a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a8795a39fde0645ac01065db01c6de62e">souffle::ast::transform::LabelDatabaseTransformer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00053">53</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

</div>
</div>
<a id="a85f36c585649d3b5d04c9564d46ef55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f36c585649d3b5d04c9564d46ef55d">&#9670;&nbsp;</a></span>MagicSetCoreTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_magic_set_core_transformer.html">MagicSetTransformer::MagicSetCoreTransformer</a> <a class="el" href="namespacesouffle_1_1ast_1_1transform.html#a85f36c585649d3b5d04c9564d46ef55d">souffle::ast::transform::MagicSetCoreTransformer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00055">55</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

</div>
</div>
<a id="ae5ba78fff322bffad406b1dcc5b4a0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ba78fff322bffad406b1dcc5b4a0de">&#9670;&nbsp;</a></span>NegativeLabellingTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_label_database_transformer_1_1_negative_labelling_transformer.html">MagicSetTransformer::LabelDatabaseTransformer::NegativeLabellingTransformer</a> <a class="el" href="namespacesouffle_1_1ast_1_1transform.html#ae5ba78fff322bffad406b1dcc5b4a0de">souffle::ast::transform::NegativeLabellingTransformer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00058">58</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

</div>
</div>
<a id="af1587e70b148038ae63c0c0350389498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1587e70b148038ae63c0c0350389498">&#9670;&nbsp;</a></span>NormaliseDatabaseTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_normalise_database_transformer.html">MagicSetTransformer::NormaliseDatabaseTransformer</a> <a class="el" href="namespacesouffle_1_1ast_1_1transform.html#af1587e70b148038ae63c0c0350389498">souffle::ast::transform::NormaliseDatabaseTransformer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00052">52</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

</div>
</div>
<a id="ad7354a99934648484ba1640209894d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7354a99934648484ba1640209894d9a">&#9670;&nbsp;</a></span>PositiveLabellingTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_magic_set_transformer_1_1_label_database_transformer_1_1_positive_labelling_transformer.html">MagicSetTransformer::LabelDatabaseTransformer::PositiveLabellingTransformer</a> <a class="el" href="namespacesouffle_1_1ast_1_1transform.html#ad7354a99934648484ba1640209894d9a">souffle::ast::transform::PositiveLabellingTransformer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00060">60</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac08b034edc612cbd02a263082b1bbc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08b034edc612cbd02a263082b1bbc46">&#9670;&nbsp;</a></span>combineAggregators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a>* souffle::ast::transform::combineAggregators </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> *&gt;&#160;</td>
          <td class="paramname"><em>aggrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00512">512</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="_inline_relations_8cpp_source.html#l00485">renameVariables()</a>, and <a class="el" href="_resolve_aliases_8cpp_source.html#l00170">rhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00534">getInlinedArgument()</a>.</p>
<div class="fragment"><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;                                                                          {</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    <span class="comment">// Due to variable scoping issues with aggregators, we rename all variables uniquely in the</span></div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    <span class="comment">// added aggregator</span></div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a1211fcf1fa30273559973f585502c936">renameVariables</a>(aggrs[0]);</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;    <span class="keywordflow">if</span> (aggrs.size() == 1) {</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        <span class="keywordflow">return</span> aggrs[0];</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    }</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    Argument* <a class="code" href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a> = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac08b034edc612cbd02a263082b1bbc46">combineAggregators</a>(std::vector&lt;Aggregator*&gt;(aggrs.begin() + 1, aggrs.end()), fun);</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    Argument* result = <span class="keyword">new</span> IntrinsicFunctor(std::move(fun), Own&lt;Argument&gt;(aggrs[0]), Own&lt;Argument&gt;(rhs));</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;}</div><div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_ac08b034edc612cbd02a263082b1bbc46"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#ac08b034edc612cbd02a263082b1bbc46">souffle::ast::transform::combineAggregators</a></div><div class="ttdeci">Argument * combineAggregators(std::vector&lt; Aggregator *&gt; aggrs, std::string fun)</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00512">InlineRelations.cpp:512</a></div></div>
<div class="ttc" id="_resolve_aliases_8cpp_html_a4e09535c06791089b6e68d7af597db7a"><div class="ttname"><a href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a></div><div class="ttdeci">Own&lt; Argument &gt; rhs</div><div class="ttdef"><b>Definition:</b> <a href="_resolve_aliases_8cpp_source.html#l00170">ResolveAliases.cpp:170</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_a1211fcf1fa30273559973f585502c936"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a1211fcf1fa30273559973f585502c936">souffle::ast::transform::renameVariables</a></div><div class="ttdeci">void renameVariables(Argument *arg)</div><div class="ttdoc">Renames all variables in a given argument uniquely. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00485">InlineRelations.cpp:485</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_ac08b034edc612cbd02a263082b1bbc46_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_ac08b034edc612cbd02a263082b1bbc46_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_ac08b034edc612cbd02a263082b1bbc46_cgraph" id="namespacesouffle_1_1ast_1_1transform_ac08b034edc612cbd02a263082b1bbc46_cgraph">
<area shape="rect" id="node2" href="namespacesouffle_1_1ast_1_1transform.html#a1211fcf1fa30273559973f585502c936" title="Renames all variables in a given argument uniquely. " alt="" coords="220,27,387,69"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584" title="souffle::clone" alt="" coords="448,5,557,32"/>
<area shape="rect" id="node4" href="classsouffle_1_1ast_1_1_node.html#a40bbdb53c63f664c2c43854dc7f0af7b" title="Apply the mapper to all child nodes. " alt="" coords="435,57,571,98"/>
</map>
</div>

</div>
</div>
<a id="a146c65e4e8a4429da50a66c746744e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146c65e4e8a4429da50a66c746744e58">&#9670;&nbsp;</a></span>combineNegatedLiterals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a>*&gt; &gt; souffle::ast::transform::combineNegatedLiterals </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> *&gt;&gt;&#160;</td>
          <td class="paramname"><em>litGroups</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the negated version of a disjunction of conjunctions. </p>
<p>E.g. (a1(x) ^ a2(x) ^ ...) v (b1(x) ^ b2(x) ^ ...) &ndash;into-&gt; (!a1(x) ^ !b1(x)) v (!a2(x) ^ !b2(x)) v ... </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00376">376</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="json11_8h_source.html#l00663">i</a>, and <a class="el" href="_inline_relations_8cpp_source.html#l00356">negateLiteral()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00431">formNegatedLiterals()</a>.</p>
<div class="fragment"><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;                                                                                                {</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    std::vector&lt;std::vector&lt;Literal*&gt;&gt; negation;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    <span class="comment">// Corner case: !() = ()</span></div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="keywordflow">if</span> (litGroups.empty()) {</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        <span class="keywordflow">return</span> negation;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    }</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    std::vector&lt;Literal*&gt; litGroup = litGroups[0];</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    <span class="keywordflow">if</span> (litGroups.size() == 1) {</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        <span class="comment">// !(a1 ^ a2 ^ a3 ^ ...) --into-&gt; !a1 v !a2 v !a3 v ...</span></div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> : litGroup) {</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;            std::vector&lt;Literal*&gt; newVec;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;            newVec.push_back(<a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d">negateLiteral</a>(<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>));</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;            negation.push_back(newVec);</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        }</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;        <span class="comment">// Done!</span></div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;        <span class="keywordflow">return</span> negation;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    }</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    <span class="comment">// Produce the negated versions of all disjunctions ignoring the first recursively</span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    std::vector&lt;std::vector&lt;Literal*&gt;&gt; combinedRHS = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a146c65e4e8a4429da50a66c746744e58">combineNegatedLiterals</a>(</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;            std::vector&lt;std::vector&lt;Literal*&gt;&gt;(litGroups.begin() + 1, litGroups.end()));</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    <span class="comment">// We now just need to add the negation of a single literal from the untouched LHS</span></div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="comment">// to every single conjunction on the RHS to finalise creating every possible combination</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="keywordflow">for</span> (Literal* lhsLit : litGroup) {</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        <span class="keywordflow">for</span> (std::vector&lt;Literal*&gt; rhsVec : combinedRHS) {</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;            std::vector&lt;Literal*&gt; newVec;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;            newVec.push_back(<a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d">negateLiteral</a>(lhsLit));</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;            <span class="keywordflow">for</span> (Literal* lit : rhsVec) {</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;                newVec.push_back(lit-&gt;clone());</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;            }</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;            negation.push_back(newVec);</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        }</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    }</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    <span class="keywordflow">for</span> (std::vector&lt;Literal*&gt; rhsVec : combinedRHS) {</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        <span class="keywordflow">for</span> (Literal* lit : rhsVec) {</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;            <span class="keyword">delete</span> lit;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        }</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    }</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    <span class="keywordflow">return</span> negation;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00663">json11.h:663</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_a146c65e4e8a4429da50a66c746744e58"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a146c65e4e8a4429da50a66c746744e58">souffle::ast::transform::combineNegatedLiterals</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; Literal * &gt; &gt; combineNegatedLiterals(std::vector&lt; std::vector&lt; Literal *&gt;&gt; litGroups)</div><div class="ttdoc">Return the negated version of a disjunction of conjunctions. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00376">InlineRelations.cpp:376</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_a940bd55ad10e760454fb7af87c1c130d"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d">souffle::ast::transform::negateLiteral</a></div><div class="ttdeci">Literal * negateLiteral(Literal *lit)</div><div class="ttdoc">Returns the negated version of a given literal. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00356">InlineRelations.cpp:356</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_a146c65e4e8a4429da50a66c746744e58_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_a146c65e4e8a4429da50a66c746744e58_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_a146c65e4e8a4429da50a66c746744e58_cgraph" id="namespacesouffle_1_1ast_1_1transform_a146c65e4e8a4429da50a66c746744e58_cgraph">
<area shape="rect" id="node2" href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d" title="Returns the negated version of a given literal. " alt="" coords="243,90,409,131"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584" title="souffle::clone" alt="" coords="771,5,881,32"/>
<area shape="rect" id="node4" href="classsouffle_1_1ast_1_1_atom.html#a25ad407a2a6ec36e21062d70ff74b24b" title="Create a clone (i.e. " alt="" coords="496,59,633,101"/>
<area shape="rect" id="node7" href="namespacesouffle_1_1ast.html#aa858fc1ad141e8a9dd2b806407c65116" title="Negate an ast constraint. " alt="" coords="457,181,672,222"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a315141918c39611929a694840f046fb5" title="souffle::fatal" alt="" coords="774,188,878,215"/>
<area shape="rect" id="node5" href="classsouffle_1_1ast_1_1_atom.html#a62f0d1457357894e5553a98a9df0deaf" title="souffle::ast::Atom\l::Atom" alt="" coords="757,122,895,163"/>
<area shape="rect" id="node6" href="classsouffle_1_1ast_1_1_node.html#ac87a64ccec4ee0e470effeef0c6f3a0b" title="Return source location of the Node. " alt="" coords="758,57,894,98"/>
<area shape="rect" id="node21" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="720,239,932,265"/>
<area shape="rect" id="node9" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61" title="tinyformat::format" alt="" coords="980,188,1123,215"/>
<area shape="rect" id="node10" href="namespacetinyformat.html#a86ed74eb3ed66a662e96220d877da964" title="Format list of arguments to the stream according to the given format string. " alt="" coords="1171,188,1321,215"/>
<area shape="rect" id="node18" href="namespacetinyformat.html#ab7b10973ec89e6601353675a85f99d61" title="tinyformat::makeFormatList" alt="" coords="1369,121,1575,148"/>
<area shape="rect" id="node11" href="namespacetinyformat_1_1detail.html#a9fe547bc617c38498e58c12cce507bec" title="tinyformat::detail\l::formatImpl" alt="" coords="1404,173,1540,214"/>
<area shape="rect" id="node19" href="namespacetinyformat.html#a970fd8292e14eb74ba55bafb41017016" title="tinyformat::printf" alt="" coords="1405,239,1539,265"/>
<area shape="rect" id="node20" href="namespacetinyformat.html#a97775445fea05ffaaa0690ab3bb1a920" title="tinyformat::printfln" alt="" coords="1399,289,1545,316"/>
<area shape="rect" id="node12" href="namespacetinyformat_1_1detail.html#ad3d636b9f85202b515c8940b7fcb62a6" title="tinyformat::detail\l::printFormatStringLiteral" alt="" coords="1624,107,1809,149"/>
<area shape="rect" id="node13" href="namespacetinyformat_1_1detail.html#ab4493739cbfe66bc79867f13f1fdf0db" title="tinyformat::detail\l::streamStateFromFormat" alt="" coords="1623,173,1811,214"/>
<area shape="rect" id="node17" href="classtinyformat_1_1detail_1_1_format_arg.html#acbf435711bbe4a4da7fc81758d7108a9" title="tinyformat::detail\l::FormatArg::format" alt="" coords="1641,238,1792,279"/>
<area shape="rect" id="node14" href="namespacetinyformat_1_1detail.html#a67285e0adb9f4164f9fc30a3eb11c771" title="tinyformat::detail\l::parseIntAndAdvance" alt="" coords="2085,143,2249,185"/>
<area shape="rect" id="node15" href="namespacetinyformat_1_1detail.html#ae1e94cbdd9e7cf26f17856a1792664e1" title="tinyformat::detail\l::parseWidthOrPrecision" alt="" coords="1859,202,2037,243"/>
<area shape="rect" id="node16" href="classtinyformat_1_1detail_1_1_format_arg.html#a91b69f66ce9dc8ca2914dce8985d7a1a" title="tinyformat::detail\l::FormatArg::toInt" alt="" coords="2099,209,2235,250"/>
</map>
</div>

</div>
</div>
<a id="adc2b2e6f9ed8feb3adfbfbfe43b96dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2b2e6f9ed8feb3adfbfbfe43b96dda">&#9670;&nbsp;</a></span>containsInlinedAtom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::transform::containsInlinedAtom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given clause contains an atom that should be inlined. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00193">193</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="_atom_8h_source.html#l00051">souffle::ast::Atom::getQualifiedName()</a>, <a class="el" href="_utils_8cpp_source.html#l00094">souffle::ast::getRelation()</a>, <a class="el" href="ast_2_relation_8h_source.html#l00107">souffle::ast::Relation::hasQualifier()</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">souffle::INLINE</a>, and <a class="el" href="ast_2utility_2_visitor_8h_source.html#l00267">souffle::ast::visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00992">souffle::ast::transform::InlineRelationsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                                                                       {</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <span class="keywordtype">bool</span> foundInlinedAtom = <span class="keyword">false</span>;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(clause, [&amp;](<span class="keyword">const</span> Atom&amp; atom) {</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        Relation* rel = <a class="code" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35">getRelation</a>(program, atom.getQualifiedName());</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        <span class="keywordflow">if</span> (rel-&gt;hasQualifier(RelationQualifier::INLINE)) {</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            foundInlinedAtom = <span class="keyword">true</span>;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        }</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    });</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    <span class="keywordflow">return</span> foundInlinedAtom;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;}</div><div class="ttc" id="namespacesouffle_1_1ast_html_af59ed6a7c649aec10999baea2f2c8b35"><div class="ttname"><a href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35">souffle::ast::getRelation</a></div><div class="ttdeci">Relation * getRelation(const Program &amp;program, const QualifiedName &amp;name)</div><div class="ttdoc">Returns the relation with the given name in the program. </div><div class="ttdef"><b>Definition:</b> <a href="_utils_8cpp_source.html#l00094">Utils.cpp:94</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_html_a0bf6b9bdf0a8866bd27dde18442ab43d"><div class="ttname"><a href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">souffle::ast::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const Node &amp;root, Visitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="ast_2utility_2_visitor_8h_source.html#l00267">Visitor.h:267</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_adc2b2e6f9ed8feb3adfbfbfe43b96dda_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_adc2b2e6f9ed8feb3adfbfbfe43b96dda_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_adc2b2e6f9ed8feb3adfbfbfe43b96dda_cgraph" id="namespacesouffle_1_1ast_1_1transform_adc2b2e6f9ed8feb3adfbfbfe43b96dda_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1ast_1_1_atom.html#ab9a22c7f862012f074559a4061696241" title="Return qualified name. " alt="" coords="234,5,382,47"/>
<area shape="rect" id="node3" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35" title="Returns the relation with the given name in the program. " alt="" coords="220,71,396,98"/>
<area shape="rect" id="node7" href="classsouffle_1_1ast_1_1_relation.html#a4f64acf8983db2fb8ba59c9273c1cf20" title="Check for a relation qualifier. " alt="" coords="231,123,385,164"/>
<area shape="rect" id="node8" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="223,188,393,229"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="477,42,581,69"/>
<area shape="rect" id="node5" href="classsouffle_1_1ast_1_1_program.html#a89bc64ed82fbb346ff8fcb922386c196" title="Return relations. " alt="" coords="450,93,607,135"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="661,101,808,127"/>
<area shape="rect" id="node9" href="namespacesouffle_1_1ast.html#a5a45867d4cbfd053ffd30af4b4e1dd9e" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="444,188,613,229"/>
<area shape="rect" id="node10" href="classsouffle_1_1ast_1_1_node.html#a332720bacd0c374ab8ff3977f0d00210" title="Obtain a list of all embedded AST child nodes. " alt="" coords="667,188,803,229"/>
</map>
</div>

</div>
</div>
<a id="a748f4a8900f05d9cd286c6d04b82ba49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748f4a8900f05d9cd286c6d04b82ba49">&#9670;&nbsp;</a></span>findInlineCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classsouffle_1_1ast_1_1_qualified_name.html">QualifiedName</a>&gt; souffle::ast::transform::findInlineCycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1analysis_1_1_precedence_graph_analysis.html">PrecedenceGraphAnalysis</a> &amp;&#160;</td>
          <td class="paramname"><em>precedenceGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; const <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> *, const <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>origins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> *&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a> &amp;&#160;</td>
          <td class="paramname"><em>unvisited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a> &amp;&#160;</td>
          <td class="paramname"><em>visiting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a> &amp;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a cycle consisting entirely of inlined relations. </p>
<p>If no cycle exists, then an empty vector is returned. </p>

<p class="definition">Definition at line <a class="el" href="_semantic_checker_8cpp_source.html#l00973">973</a> of file <a class="el" href="_semantic_checker_8cpp_source.html">SemanticChecker.cpp</a>.</p>

<p class="reference">References <a class="el" href="ast_2_relation_8h_source.html#l00051">souffle::ast::Relation::getQualifiedName()</a>, <a class="el" href="_precedence_graph_8h_source.html#l00046">souffle::ast::analysis::PrecedenceGraphAnalysis::graph()</a>, and <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">souffle::INLINE</a>.</p>

<p class="reference">Referenced by <a class="el" href="_semantic_checker_8cpp_source.html#l01051">souffle::ast::transform::SemanticCheckerImpl::checkInlining()</a>.</p>
<div class="fragment"><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;                                                     {</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;    std::vector&lt;QualifiedName&gt; result;</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;    <span class="keywordflow">if</span> (current == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;        <span class="comment">// Not looking at any nodes at the moment, so choose any node from the unvisited list</span></div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;        <span class="keywordflow">if</span> (unvisited.empty()) {</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;            <span class="comment">// Nothing left to visit - so no cycles exist!</span></div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;            <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;        }</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;        <span class="comment">// Choose any element from the unvisited set</span></div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;        current = *unvisited.begin();</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;        origins[current] = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;        <span class="comment">// Move it to &quot;currently visiting&quot;</span></div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;        unvisited.erase(current);</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;        visiting.insert(current);</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;        <span class="comment">// Check if we can find a cycle beginning from this node</span></div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;        std::vector&lt;QualifiedName&gt; subresult =</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;                <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a748f4a8900f05d9cd286c6d04b82ba49">findInlineCycle</a>(precedenceGraph, origins, current, unvisited, visiting, visited);</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;        <span class="keywordflow">if</span> (subresult.empty()) {</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;            <span class="comment">// No cycle found, try again from another node</span></div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a748f4a8900f05d9cd286c6d04b82ba49">findInlineCycle</a>(precedenceGraph, origins, <span class="keyword">nullptr</span>, unvisited, visiting, visited);</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;            <span class="comment">// Cycle found! Return it</span></div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;            <span class="keywordflow">return</span> subresult;</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;        }</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;    }</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;    <span class="comment">// Check neighbours</span></div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">RelationSet</a>&amp; successors = precedenceGraph.graph().successors(current);</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Relation* successor : successors) {</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;        <span class="comment">// Only care about inlined neighbours in the graph</span></div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;        <span class="keywordflow">if</span> (successor-&gt;hasQualifier(RelationQualifier::INLINE)) {</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;            <span class="keywordflow">if</span> (visited.find(successor) != visited.end()) {</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;                <span class="comment">// The neighbour has already been visited, so move on</span></div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;                <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;            }</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;            <span class="keywordflow">if</span> (visiting.find(successor) != visiting.end()) {</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;                <span class="comment">// Found a cycle!!</span></div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;                <span class="comment">// Construct the cycle in reverse</span></div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;                <span class="keywordflow">while</span> (current != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;                    result.push_back(current-&gt;getQualifiedName());</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;                    current = origins[current];</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;                }</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;                <span class="keywordflow">return</span> result;</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;            }</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;            <span class="comment">// Node has not been visited yet</span></div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;            origins[successor] = current;</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;            <span class="comment">// Move from unvisited to visiting</span></div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;            unvisited.erase(successor);</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;            visiting.insert(successor);</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;            <span class="comment">// Visit recursively and check if a cycle is formed</span></div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;            std::vector&lt;QualifiedName&gt; subgraphCycle =</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;                    <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a748f4a8900f05d9cd286c6d04b82ba49">findInlineCycle</a>(precedenceGraph, origins, successor, unvisited, visiting, visited);</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;            <span class="keywordflow">if</span> (!subgraphCycle.empty()) {</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;                <span class="comment">// Found a cycle!</span></div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;                <span class="keywordflow">return</span> subgraphCycle;</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;            }</div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;        }</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;    }</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;    <span class="comment">// Visited all neighbours with no cycle found, so done visiting this node.</span></div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;    visiting.erase(current);</div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;    visited.insert(current);</div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;    <span class="keywordflow">return</span> result;</div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;}</div><div class="ttc" id="namespacesouffle_1_1ast_html_a91b7228545d71d053324a666e48a528c"><div class="ttname"><a href="namespacesouffle_1_1ast.html#a91b7228545d71d053324a666e48a528c">souffle::ast::RelationSet</a></div><div class="ttdeci">std::set&lt; const Relation *, NameComparison &gt; RelationSet</div><div class="ttdoc">Relation set. </div><div class="ttdef"><b>Definition:</b> <a href="ast_2_relation_8h_source.html#l00174">Relation.h:174</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_a748f4a8900f05d9cd286c6d04b82ba49"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a748f4a8900f05d9cd286c6d04b82ba49">souffle::ast::transform::findInlineCycle</a></div><div class="ttdeci">std::vector&lt; QualifiedName &gt; findInlineCycle(const PrecedenceGraphAnalysis &amp;precedenceGraph, std::map&lt; const Relation *, const Relation *&gt; &amp;origins, const Relation *current, RelationSet &amp;unvisited, RelationSet &amp;visiting, RelationSet &amp;visited)</div><div class="ttdoc">Find a cycle consisting entirely of inlined relations. </div><div class="ttdef"><b>Definition:</b> <a href="_semantic_checker_8cpp_source.html#l00973">SemanticChecker.cpp:973</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_a748f4a8900f05d9cd286c6d04b82ba49_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_a748f4a8900f05d9cd286c6d04b82ba49_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_a748f4a8900f05d9cd286c6d04b82ba49_cgraph" id="namespacesouffle_1_1ast_1_1transform_a748f4a8900f05d9cd286c6d04b82ba49_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1ast_1_1_relation.html#aec7a180cc23c066453f1e97e9957ccfe" title="Get qualified relation name. " alt="" coords="242,5,397,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1ast_1_1analysis_1_1_precedence_graph_analysis.html#a7bc037361ff9de496a473935e3dc9724" title="souffle::ast::analysis\l::PrecedenceGraphAnalysis\l::graph" alt="" coords="220,71,419,127"/>
</map>
</div>

</div>
</div>
<a id="a8a7455cc2262cc907c15e6124ac6588a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7455cc2262cc907c15e6124ac6588a">&#9670;&nbsp;</a></span>formNegatedLiterals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a>*&gt; &gt; souffle::ast::transform::formNegatedLiterals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>atom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the bodies that will replace the negation of a given inlined atom. </p>
<p>E.g. a(x) &lt;- (a11(x), a12(x)) ; (a21(x), a22(x)) =&gt; !a(x) &lt;- (!a11(x), !a21(x)) ; (!a11(x), !a22(x)) ; ... Essentially, produce every combination (m_1 ^ m_2 ^ ...) where m_i is the negation of a literal in the ith rule of a. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00431">431</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="_inline_relations_8cpp_source.html#l00376">combineNegatedLiterals()</a>, <a class="el" href="_utils_8cpp_source.html#l00070">souffle::ast::getClauses()</a>, <a class="el" href="_atom_8h_source.html#l00051">souffle::ast::Atom::getQualifiedName()</a>, <a class="el" href="_utils_8cpp_source.html#l00094">souffle::ast::getRelation()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00075">souffle::ast::transform::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00295">inlineBodyLiterals()</a>, and <a class="el" href="_inline_relations_8cpp_source.html#l00071">souffle::ast::transform::NullableVector&lt; T &gt;::isValid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00775">getInlinedLiteral()</a>.</p>
<div class="fragment"><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;                                                                                 {</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    <span class="comment">// Constraints added to unify atoms should not be negated and should be added to</span></div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    <span class="comment">// all the final rule combinations produced, and so should be stored separately.</span></div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    std::vector&lt;std::vector&lt;Literal*&gt;&gt; addedBodyLiterals;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    std::vector&lt;std::vector&lt;BinaryConstraint*&gt;&gt; addedConstraints;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    <span class="comment">// Go through every possible clause associated with the given atom</span></div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    <span class="keywordflow">for</span> (Clause* inClause : <a class="code" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f">getClauses</a>(program, *<a class="code" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35">getRelation</a>(program, atom-&gt;getQualifiedName()))) {</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        <span class="comment">// Form the replacement clause by inlining based on the current clause</span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        std::pair&lt;NullableVector&lt;Literal*&gt;, std::vector&lt;BinaryConstraint*&gt;&gt; inlineResult =</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23">inlineBodyLiterals</a>(atom, inClause);</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        NullableVector&lt;Literal*&gt; replacementBodyLiterals = inlineResult.first;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        std::vector&lt;BinaryConstraint*&gt; currConstraints = inlineResult.second;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        <span class="keywordflow">if</span> (!replacementBodyLiterals.isValid()) {</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;            <span class="comment">// Failed to unify, so just move on</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;        }</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        addedBodyLiterals.push_back(replacementBodyLiterals.getVector());</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;        addedConstraints.push_back(currConstraints);</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    }</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    <span class="comment">// We now have a list of bodies needed to inline the given atom.</span></div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    <span class="comment">// We want to inline the negated version, however, which is done using De Morgan&#39;s Law.</span></div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    std::vector&lt;std::vector&lt;Literal*&gt;&gt; negatedAddedBodyLiterals = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a146c65e4e8a4429da50a66c746744e58">combineNegatedLiterals</a>(addedBodyLiterals);</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    <span class="comment">// Add in the necessary constraints to all the body literals</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; negatedAddedBodyLiteral : negatedAddedBodyLiterals) {</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;        <span class="keywordflow">for</span> (std::vector&lt;BinaryConstraint*&gt; constraintGroup : addedConstraints) {</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;            <span class="keywordflow">for</span> (BinaryConstraint* constraint : constraintGroup) {</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                negatedAddedBodyLiteral.push_back(constraint-&gt;clone());</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;            }</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;        }</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    }</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    <span class="comment">// Free up the old body literals and constraints</span></div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    <span class="keywordflow">for</span> (std::vector&lt;Literal*&gt; litGroup : addedBodyLiterals) {</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        <span class="keywordflow">for</span> (Literal* lit : litGroup) {</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;            <span class="keyword">delete</span> lit;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        }</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    }</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    <span class="keywordflow">for</span> (std::vector&lt;BinaryConstraint*&gt; consGroup : addedConstraints) {</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        <span class="keywordflow">for</span> (Constraint* cons : consGroup) {</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;            <span class="keyword">delete</span> cons;</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;        }</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    }</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    <span class="keywordflow">return</span> negatedAddedBodyLiterals;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;}</div><div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_a3ce47150ce3942c816dc5d8286f3ee23"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23">souffle::ast::transform::inlineBodyLiterals</a></div><div class="ttdeci">std::pair&lt; NullableVector&lt; Literal * &gt;, std::vector&lt; BinaryConstraint * &gt; &gt; inlineBodyLiterals(Atom *atom, Clause *atomInlineClause)</div><div class="ttdoc">Inlines the given atom based on a given clause. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00295">InlineRelations.cpp:295</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_html_af59ed6a7c649aec10999baea2f2c8b35"><div class="ttname"><a href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35">souffle::ast::getRelation</a></div><div class="ttdeci">Relation * getRelation(const Program &amp;program, const QualifiedName &amp;name)</div><div class="ttdoc">Returns the relation with the given name in the program. </div><div class="ttdef"><b>Definition:</b> <a href="_utils_8cpp_source.html#l00094">Utils.cpp:94</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_a146c65e4e8a4429da50a66c746744e58"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a146c65e4e8a4429da50a66c746744e58">souffle::ast::transform::combineNegatedLiterals</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; Literal * &gt; &gt; combineNegatedLiterals(std::vector&lt; std::vector&lt; Literal *&gt;&gt; litGroups)</div><div class="ttdoc">Return the negated version of a disjunction of conjunctions. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00376">InlineRelations.cpp:376</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_html_a4aa067ee069beebb52dff5ee7250fc5f"><div class="ttname"><a href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f">souffle::ast::getClauses</a></div><div class="ttdeci">std::vector&lt; Clause * &gt; getClauses(const Program &amp;program, const QualifiedName &amp;relationName)</div><div class="ttdoc">Returns a vector of clauses in the program describing the relation with the given name...</div><div class="ttdef"><b>Definition:</b> <a href="_utils_8cpp_source.html#l00070">Utils.cpp:70</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_a8a7455cc2262cc907c15e6124ac6588a_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_a8a7455cc2262cc907c15e6124ac6588a_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_a8a7455cc2262cc907c15e6124ac6588a_cgraph" id="namespacesouffle_1_1ast_1_1transform_a8a7455cc2262cc907c15e6124ac6588a_cgraph">
<area shape="rect" id="node2" href="namespacesouffle_1_1ast_1_1transform.html#a146c65e4e8a4429da50a66c746744e58" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="223,307,412,349"/>
<area shape="rect" id="node23" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="678,387,853,413"/>
<area shape="rect" id="node26" href="classsouffle_1_1ast_1_1_atom.html#ab9a22c7f862012f074559a4061696241" title="Return qualified name. " alt="" coords="935,539,1083,581"/>
<area shape="rect" id="node27" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35" title="Returns the relation with the given name in the program. " alt="" coords="677,437,853,464"/>
<area shape="rect" id="node30" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html#ab1413c473cb705a7ce19d8e2bafa2509" title="souffle::ast::transform\l::NullableVector::getVector" alt="" coords="220,711,415,753"/>
<area shape="rect" id="node33" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23" title="Inlines the given atom based on a given clause. " alt="" coords="682,977,849,1018"/>
<area shape="rect" id="node38" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html#a9603290d354fffc43865cb122b514abf" title="souffle::ast::transform\l::NullableVector::isValid" alt="" coords="1182,1035,1358,1077"/>
<area shape="rect" id="node3" href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d" title="Returns the negated version of a given literal. " alt="" coords="682,187,849,229"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584" title="souffle::clone" alt="" coords="1679,671,1789,697"/>
<area shape="rect" id="node5" href="classsouffle_1_1ast_1_1_atom.html#a25ad407a2a6ec36e21062d70ff74b24b" title="Create a clone (i.e. " alt="" coords="940,187,1077,229"/>
<area shape="rect" id="node8" href="namespacesouffle_1_1ast.html#aa858fc1ad141e8a9dd2b806407c65116" title="Negate an ast constraint. " alt="" coords="901,70,1116,111"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a315141918c39611929a694840f046fb5" title="souffle::fatal" alt="" coords="1218,107,1322,133"/>
<area shape="rect" id="node6" href="classsouffle_1_1ast_1_1_atom.html#a62f0d1457357894e5553a98a9df0deaf" title="souffle::ast::Atom\l::Atom" alt="" coords="1201,158,1339,199"/>
<area shape="rect" id="node7" href="classsouffle_1_1ast_1_1_node.html#ac87a64ccec4ee0e470effeef0c6f3a0b" title="Return source location of the Node. " alt="" coords="1202,539,1338,581"/>
<area shape="rect" id="node22" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="1164,56,1376,83"/>
<area shape="rect" id="node10" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61" title="tinyformat::format" alt="" coords="1446,107,1589,133"/>
<area shape="rect" id="node11" href="namespacetinyformat.html#a86ed74eb3ed66a662e96220d877da964" title="Format list of arguments to the stream according to the given format string. " alt="" coords="1659,107,1809,133"/>
<area shape="rect" id="node19" href="namespacetinyformat.html#ab7b10973ec89e6601353675a85f99d61" title="tinyformat::makeFormatList" alt="" coords="1857,173,2063,200"/>
<area shape="rect" id="node12" href="namespacetinyformat_1_1detail.html#a9fe547bc617c38498e58c12cce507bec" title="tinyformat::detail\l::formatImpl" alt="" coords="1892,107,2028,149"/>
<area shape="rect" id="node20" href="namespacetinyformat.html#a970fd8292e14eb74ba55bafb41017016" title="tinyformat::printf" alt="" coords="1893,5,2027,32"/>
<area shape="rect" id="node21" href="namespacetinyformat.html#a97775445fea05ffaaa0690ab3bb1a920" title="tinyformat::printfln" alt="" coords="1887,56,2033,83"/>
<area shape="rect" id="node13" href="namespacetinyformat_1_1detail.html#ad3d636b9f85202b515c8940b7fcb62a6" title="tinyformat::detail\l::printFormatStringLiteral" alt="" coords="2112,42,2297,83"/>
<area shape="rect" id="node14" href="namespacetinyformat_1_1detail.html#ab4493739cbfe66bc79867f13f1fdf0db" title="tinyformat::detail\l::streamStateFromFormat" alt="" coords="2111,107,2299,149"/>
<area shape="rect" id="node18" href="classtinyformat_1_1detail_1_1_format_arg.html#acbf435711bbe4a4da7fc81758d7108a9" title="tinyformat::detail\l::FormatArg::format" alt="" coords="2129,173,2280,214"/>
<area shape="rect" id="node15" href="namespacetinyformat_1_1detail.html#a67285e0adb9f4164f9fc30a3eb11c771" title="tinyformat::detail\l::parseIntAndAdvance" alt="" coords="2573,78,2737,119"/>
<area shape="rect" id="node16" href="namespacetinyformat_1_1detail.html#ae1e94cbdd9e7cf26f17856a1792664e1" title="tinyformat::detail\l::parseWidthOrPrecision" alt="" coords="2347,137,2525,178"/>
<area shape="rect" id="node17" href="classtinyformat_1_1detail_1_1_format_arg.html#a91b69f66ce9dc8ca2914dce8985d7a1a" title="tinyformat::detail\l::FormatArg::toInt" alt="" coords="2587,143,2723,185"/>
<area shape="rect" id="node24" href="classsouffle_1_1ast_1_1_program.html#a529839d448f4139ce2e4e87bcfe3201f" title="Return clauses. " alt="" coords="930,305,1087,346"/>
<area shape="rect" id="node25" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1444,429,1591,456"/>
<area shape="rect" id="node28" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="957,371,1061,397"/>
<area shape="rect" id="node29" href="classsouffle_1_1ast_1_1_program.html#a89bc64ed82fbb346ff8fcb922386c196" title="Return relations. " alt="" coords="930,422,1087,463"/>
<area shape="rect" id="node31" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e" title="Tries to perform a single step of inlining on the given literal. " alt="" coords="463,671,629,713"/>
<area shape="rect" id="node32" href="classsouffle_1_1ast_1_1_relation.html#a4f64acf8983db2fb8ba59c9273c1cf20" title="Check for a relation qualifier. " alt="" coords="688,625,843,666"/>
<area shape="rect" id="node39" href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd" title="Returns a vector of atoms that should replace the given atom after one step of inlining. " alt="" coords="682,690,849,731"/>
<area shape="rect" id="node40" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f" title="Returns a vector of arguments that should replace the given argument after one step of inlining..." alt="" coords="925,823,1092,865"/>
<area shape="rect" id="node34" href="namespacesouffle_1_1ast_1_1transform.html#a4ef7394d84d020c597cb916fa67ff8ed" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="925,758,1092,799"/>
<area shape="rect" id="node35" href="classsouffle_1_1ast_1_1_atom.html#a48b2afc7e3e22611a93b42f0089342d8" title="Return arguments. " alt="" coords="1201,605,1339,646"/>
<area shape="rect" id="node36" href="namespacesouffle_1_1ast_1_1transform.html#aef0f3b772710ab151915d04c2538070e" title="Reduces a vector of substitutions. " alt="" coords="1187,722,1353,763"/>
<area shape="rect" id="node37" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1" title="A generic factory for constraints of the form. " alt="" coords="1424,729,1611,756"/>
<area shape="rect" id="node41" href="classsouffle_1_1ast_1_1_aggregator.html#a89b1301ec904219812c93d5eb62b2c3e" title="Set body. " alt="" coords="1183,905,1357,946"/>
<area shape="rect" id="node42" href="namespacesouffle_1_1ast_1_1transform.html#ac08b034edc612cbd02a263082b1bbc46" title="souffle::ast::transform\l::combineAggregators" alt="" coords="1187,970,1353,1011"/>
<area shape="rect" id="node45" href="classsouffle_1_1ast_1_1_node.html#a8eab0e38c9a5343d641d5b2eb631733a" title="Set source location for the Node. " alt="" coords="1202,839,1338,881"/>
<area shape="rect" id="node43" href="namespacesouffle_1_1ast_1_1transform.html#a1211fcf1fa30273559973f585502c936" title="Renames all variables in a given argument uniquely. " alt="" coords="1434,905,1601,946"/>
<area shape="rect" id="node44" href="classsouffle_1_1ast_1_1_node.html#a40bbdb53c63f664c2c43854dc7f0af7b" title="Apply the mapper to all child nodes. " alt="" coords="1666,905,1802,946"/>
</map>
</div>

</div>
</div>
<a id="ac78e04494a4e67eb9ae63a399c99d92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78e04494a4e67eb9ae63a399c99d92f">&#9670;&nbsp;</a></span>getInlinedArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt;<a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a>*&gt; souffle::ast::transform::getInlinedArgument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of arguments that should replace the given argument after one step of inlining. </p>
<p>Note: This function is currently generalised to perform any required inlining within aggregators as well, making it simple to extend to this later on if desired (and the semantic check is removed). </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00534">534</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="_container_util_8h_source.html#l00166">souffle::clone()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00512">combineAggregators()</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4905ac9d6a22bdfc1ae096094ce6248d">souffle::COUNT</a>, <a class="el" href="_misc_util_8h_source.html#l00192">souffle::fatal()</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">souffle::FMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">souffle::FMIN</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a0645fcc11b74dbdbf2d7501942fa6f6f">souffle::FSUM</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00775">getInlinedLiteral()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00075">souffle::ast::transform::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="json11_8h_source.html#l00663">i</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00071">souffle::ast::transform::NullableVector&lt; T &gt;::isValid()</a>, <a class="el" href="html_js_chartist_min_8h_source.html#l00015">j</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">souffle::MAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4ea6d1161ea24d7599365f574aff6610">souffle::MEAN</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">souffle::MIN</a>, <a class="el" href="_aggregator_8h_source.html#l00072">souffle::ast::Aggregator::setBody()</a>, <a class="el" href="ast_2_node_8h_source.html#l00045">souffle::ast::Node::setSrcLoc()</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a6970bdc2201030b9c03fbdcf3973858a">souffle::SUM</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">souffle::UMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">souffle::UMIN</a>, <a class="el" href="_misc_util_8h_source.html#l00200">UNREACHABLE_BAD_CASE_ANALYSIS</a>, and <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ae6246115490f016a4ecb2604ba5fc2ed">souffle::USUM</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00719">getInlinedAtom()</a>, and <a class="el" href="_inline_relations_8cpp_source.html#l00775">getInlinedLiteral()</a>.</p>
<div class="fragment"><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;                                                                                    {</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;    std::vector&lt;Argument*&gt; versions;</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    <span class="comment">// Each argument has to be handled differently - essentially, want to go down to</span></div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    <span class="comment">// nested aggregators, and inline their bodies if needed.</span></div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* aggr = dynamic_cast&lt;const Aggregator*&gt;(arg)) {</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;        <span class="comment">// First try inlining the target expression if necessary</span></div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;        <span class="keywordflow">if</span> (aggr-&gt;getTargetExpression() != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;            NullableVector&lt;Argument*&gt; argumentVersions =</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;                    <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a>(program, aggr-&gt;getTargetExpression());</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;            <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                <span class="comment">// An element in the target expression can be inlined!</span></div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;                changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                <span class="comment">// Create a new aggregator per version of the target expression</span></div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;                <span class="keywordflow">for</span> (Argument* newArg : argumentVersions.getVector()) {</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;                    <span class="keyword">auto</span>* newAggr = <span class="keyword">new</span> Aggregator(aggr-&gt;getOperator(), Own&lt;Argument&gt;(newArg));</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;                    VecOwn&lt;Literal&gt; newBody;</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;                    <span class="keywordflow">for</span> (Literal* lit : aggr-&gt;getBodyLiterals()) {</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;                        newBody.push_back(<a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(lit));</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;                    }</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;                    newAggr-&gt;setBody(std::move(newBody));</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;                    versions.push_back(newAggr);</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;                }</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;            }</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;        }</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;        <span class="comment">// Try inlining body arguments if the target expression has not been changed.</span></div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        <span class="comment">// (At this point we only handle one step of inlining at a time)</span></div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;        <span class="keywordflow">if</span> (!changed) {</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;            std::vector&lt;Literal*&gt; bodyLiterals = aggr-&gt;getBodyLiterals();</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; bodyLiterals.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;                Literal* currLit = bodyLiterals[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;                NullableVector&lt;std::vector&lt;Literal*&gt;&gt; literalVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e">getInlinedLiteral</a>(program, currLit);</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;                <span class="keywordflow">if</span> (literalVersions.isValid()) {</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;                    <span class="comment">// Literal can be inlined!</span></div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;                    changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;                    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a> op = aggr-&gt;getOperator();</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;                    <span class="comment">// Create an aggregator (with the same operation) for each possible body</span></div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;                    std::vector&lt;Aggregator*&gt; aggrVersions;</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;                    <span class="keywordflow">for</span> (std::vector&lt;Literal*&gt; inlineVersions : literalVersions.getVector()) {</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;                        Own&lt;Argument&gt; target;</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;                        <span class="keywordflow">if</span> (aggr-&gt;getTargetExpression() != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;                            target = <a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(aggr-&gt;getTargetExpression());</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;                        }</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;                        <span class="keyword">auto</span>* newAggr = <span class="keyword">new</span> Aggregator(aggr-&gt;getOperator(), std::move(target));</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                        VecOwn&lt;Literal&gt; newBody;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                        <span class="comment">// Add in everything except the current literal being replaced</span></div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = 0; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> &lt; bodyLiterals.size(); <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>++) {</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;                            <span class="keywordflow">if</span> (<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> != <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>) {</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;                                newBody.push_back(<a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(bodyLiterals[<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>]));</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                            }</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;                        }</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;                        <span class="comment">// Add in everything new that replaces that literal</span></div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;                        <span class="keywordflow">for</span> (Literal* addedLit : inlineVersions) {</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;                            newBody.push_back(Own&lt;Literal&gt;(addedLit));</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;                        }</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;                        newAggr-&gt;setBody(std::move(newBody));</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;                        aggrVersions.push_back(newAggr);</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;                    }</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                    <span class="comment">// Utility lambda: get functor used to tie aggregators together.</span></div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                    <span class="keyword">auto</span> aggregateToFunctor = [](<a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a> op) {</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                        <span class="keywordflow">switch</span> (op) {</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::MIN:</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::FMIN:</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::UMIN: <span class="keywordflow">return</span> <span class="stringliteral">&quot;min&quot;</span>;</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::MAX:</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::FMAX:</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::UMAX: <span class="keywordflow">return</span> <span class="stringliteral">&quot;max&quot;</span>;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::SUM:</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::FSUM:</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::USUM:</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::COUNT: <span class="keywordflow">return</span> <span class="stringliteral">&quot;+&quot;</span>;</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::MEAN: <a class="code" href="namespacesouffle.html#a315141918c39611929a694840f046fb5">fatal</a>(<span class="stringliteral">&quot;no translation&quot;</span>);</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                        }</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                        <a class="code" href="_misc_util_8h.html#a80064103b41e5e72405c38edf202af56">UNREACHABLE_BAD_CASE_ANALYSIS</a></div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;                    };</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;                    <span class="comment">// Create the actual overall aggregator that ties the replacement aggregators together.</span></div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;                    <span class="comment">// example: min x : { a(x) }. &lt;=&gt; min ( min x : { a1(x) }, min x : { a2(x) }, ... )</span></div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                    <span class="keywordflow">if</span> (op != AggregateOp::MEAN) {</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                        versions.push_back(<a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac08b034edc612cbd02a263082b1bbc46">combineAggregators</a>(aggrVersions, aggregateToFunctor(op)));</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                    }</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;                }</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;                <span class="comment">// Only perform one stage of inlining at a time.</span></div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;                <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;                }</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;            }</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        }</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* functor = dynamic_cast&lt;const Functor*&gt;(arg)) {</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;        <span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0;</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> funArg : functor-&gt;getArguments()) {</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;            <span class="comment">// TODO (azreika): use unique pointers</span></div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;            <span class="comment">// try inlining each argument from left to right</span></div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;            NullableVector&lt;Argument*&gt; argumentVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a>(program, funArg);</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;            <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;                changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;                <span class="keywordflow">for</span> (Argument* newArgVersion : argumentVersions.getVector()) {</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;                    <span class="comment">// same functor but with new argument version</span></div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;                    VecOwn&lt;Argument&gt; argsCopy;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;                    <span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = 0;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;                    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; functorArg : functor-&gt;getArguments()) {</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;                        <span class="keywordflow">if</span> (j == i) {</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;                            argsCopy.emplace_back(newArgVersion);</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;                        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;                            argsCopy.emplace_back(functorArg-&gt;clone());</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;                        }</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;                        ++<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;                    }</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;                    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* intrFunc = dynamic_cast&lt;const IntrinsicFunctor*&gt;(arg)) {</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                        <span class="keyword">auto</span>* newFunctor = <span class="keyword">new</span> IntrinsicFunctor(intrFunc-&gt;getFunction(), std::move(argsCopy));</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                        newFunctor-&gt;setSrcLoc(functor-&gt;getSrcLoc());</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                        versions.push_back(newFunctor);</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* userFunc = dynamic_cast&lt;const UserDefinedFunctor*&gt;(arg)) {</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                        <span class="keyword">auto</span>* newFunctor = <span class="keyword">new</span> UserDefinedFunctor(userFunc-&gt;getName(), std::move(argsCopy));</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;                        newFunctor-&gt;setSrcLoc(userFunc-&gt;getSrcLoc());</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;                        versions.push_back(newFunctor);</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;                    }</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;                }</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;                <span class="comment">// only one step at a time</span></div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;            }</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;            ++<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;        }</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* cast = dynamic_cast&lt;const ast::TypeCast*&gt;(arg)) {</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;        NullableVector&lt;Argument*&gt; argumentVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a>(program, cast-&gt;getValue());</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;        <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;            changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;            <span class="keywordflow">for</span> (Argument* newArg : argumentVersions.getVector()) {</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;                Argument* newTypeCast = <span class="keyword">new</span> ast::TypeCast(Own&lt;Argument&gt;(newArg), cast-&gt;getType());</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;                versions.push_back(newTypeCast);</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;            }</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;        }</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* record = dynamic_cast&lt;const RecordInit*&gt;(arg)) {</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;        std::vector&lt;Argument*&gt; recordArguments = record-&gt;getArguments();</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; recordArguments.size(); i++) {</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;            Argument* currentRecArg = recordArguments[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;            NullableVector&lt;Argument*&gt; argumentVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a>(program, currentRecArg);</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;            <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;                changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;                <span class="keywordflow">for</span> (Argument* newArgumentVersion : argumentVersions.getVector()) {</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;                    <span class="keyword">auto</span>* newRecordArg = <span class="keyword">new</span> RecordInit();</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; recordArguments.size(); j++) {</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;                        <span class="keywordflow">if</span> (i == j) {</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;                            newRecordArg-&gt;addArgument(Own&lt;Argument&gt;(newArgumentVersion));</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;                        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;                            newRecordArg-&gt;addArgument(<a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(recordArguments[j]));</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;                        }</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;                    }</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;                    versions.push_back(newRecordArg);</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;                }</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;            }</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;            <span class="comment">// Only perform one stage of inlining at a time.</span></div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;            <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;            }</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;        }</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;    }</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;    <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;        <span class="comment">// Return a valid vector - replacements need to be made!</span></div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;Argument*&gt;(versions);</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;        <span class="comment">// Return an invalid vector - no inlining has occurred</span></div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;Argument*&gt;();</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;    }</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;}</div><div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_ac08b034edc612cbd02a263082b1bbc46"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#ac08b034edc612cbd02a263082b1bbc46">souffle::ast::transform::combineAggregators</a></div><div class="ttdeci">Argument * combineAggregators(std::vector&lt; Aggregator *&gt; aggrs, std::string fun)</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00512">InlineRelations.cpp:512</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">souffle::AggregateOp</a></div><div class="ttdeci">AggregateOp</div><div class="ttdoc">Types of aggregation functions. </div><div class="ttdef"><b>Definition:</b> <a href="_aggregate_op_8h_source.html#l00028">AggregateOp.h:28</a></div></div>
<div class="ttc" id="namespacesouffle_html_a1dd578fbaf92e67ee52ebdd8cf364584"><div class="ttname"><a href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a></div><div class="ttdeci">auto clone(const std::vector&lt; A *&gt; &amp;xs)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00166">ContainerUtil.h:166</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00663">json11.h:663</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_a60d908235c9c6d168bdfb2098b55090e"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e">souffle::ast::transform::getInlinedLiteral</a></div><div class="ttdeci">NullableVector&lt; std::vector&lt; Literal * &gt; &gt; getInlinedLiteral(Program &amp;, Literal *)</div><div class="ttdoc">Tries to perform a single step of inlining on the given literal. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00775">InlineRelations.cpp:775</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_aab858032a95af802114b255fac6f45f2"><div class="ttname"><a href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a></div><div class="ttdeci">var j</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a315141918c39611929a694840f046fb5"><div class="ttname"><a href="namespacesouffle.html#a315141918c39611929a694840f046fb5">souffle::fatal</a></div><div class="ttdeci">void fatal(const char *format, const Args &amp;... args)</div><div class="ttdef"><b>Definition:</b> <a href="_misc_util_8h_source.html#l00192">MiscUtil.h:192</a></div></div>
<div class="ttc" id="_misc_util_8h_html_a80064103b41e5e72405c38edf202af56"><div class="ttname"><a href="_misc_util_8h.html#a80064103b41e5e72405c38edf202af56">UNREACHABLE_BAD_CASE_ANALYSIS</a></div><div class="ttdeci">#define UNREACHABLE_BAD_CASE_ANALYSIS</div><div class="ttdef"><b>Definition:</b> <a href="_misc_util_8h_source.html#l00200">MiscUtil.h:200</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_ac78e04494a4e67eb9ae63a399c99d92f"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">souffle::ast::transform::getInlinedArgument</a></div><div class="ttdeci">NullableVector&lt; Argument * &gt; getInlinedArgument(Program &amp;program, const Argument *arg)</div><div class="ttdoc">Returns a vector of arguments that should replace the given argument after one step of inlining...</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00534">InlineRelations.cpp:534</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_ac78e04494a4e67eb9ae63a399c99d92f_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_ac78e04494a4e67eb9ae63a399c99d92f_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_ac78e04494a4e67eb9ae63a399c99d92f_cgraph" id="namespacesouffle_1_1ast_1_1transform_ac78e04494a4e67eb9ae63a399c99d92f_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584" title="souffle::clone" alt="" coords="1451,243,1561,270"/>
<area shape="rect" id="node3" href="namespacesouffle_1_1ast_1_1transform.html#ac08b034edc612cbd02a263082b1bbc46" title="souffle::ast::transform\l::combineAggregators" alt="" coords="224,105,391,147"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a315141918c39611929a694840f046fb5" title="souffle::fatal" alt="" coords="1454,645,1558,671"/>
<area shape="rect" id="node19" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e" title="Tries to perform a single step of inlining on the given literal. " alt="" coords="224,521,391,563"/>
<area shape="rect" id="node32" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html#a9603290d354fffc43865cb122b514abf" title="souffle::ast::transform\l::NullableVector::isValid" alt="" coords="904,204,1080,245"/>
<area shape="rect" id="node33" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html#ab1413c473cb705a7ce19d8e2bafa2509" title="souffle::ast::transform\l::NullableVector::getVector" alt="" coords="895,773,1089,815"/>
<area shape="rect" id="node44" href="classsouffle_1_1ast_1_1_aggregator.html#a89b1301ec904219812c93d5eb62b2c3e" title="Set body. " alt="" coords="220,941,395,983"/>
<area shape="rect" id="node45" href="classsouffle_1_1ast_1_1_node.html#a8eab0e38c9a5343d641d5b2eb631733a" title="Set source location for the Node. " alt="" coords="239,1007,375,1048"/>
<area shape="rect" id="node4" href="namespacesouffle_1_1ast_1_1transform.html#a1211fcf1fa30273559973f585502c936" title="Renames all variables in a given argument uniquely. " alt="" coords="443,95,609,136"/>
<area shape="rect" id="node5" href="classsouffle_1_1ast_1_1_node.html#a40bbdb53c63f664c2c43854dc7f0af7b" title="Apply the mapper to all child nodes. " alt="" coords="684,95,820,136"/>
<area shape="rect" id="node7" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61" title="tinyformat::format" alt="" coords="1660,645,1803,671"/>
<area shape="rect" id="node8" href="namespacetinyformat.html#a86ed74eb3ed66a662e96220d877da964" title="Format list of arguments to the stream according to the given format string. " alt="" coords="1851,645,2001,671"/>
<area shape="rect" id="node16" href="namespacetinyformat.html#ab7b10973ec89e6601353675a85f99d61" title="tinyformat::makeFormatList" alt="" coords="2049,578,2255,605"/>
<area shape="rect" id="node9" href="namespacetinyformat_1_1detail.html#a9fe547bc617c38498e58c12cce507bec" title="tinyformat::detail\l::formatImpl" alt="" coords="2084,629,2220,671"/>
<area shape="rect" id="node17" href="namespacetinyformat.html#a970fd8292e14eb74ba55bafb41017016" title="tinyformat::printf" alt="" coords="2085,695,2219,722"/>
<area shape="rect" id="node18" href="namespacetinyformat.html#a97775445fea05ffaaa0690ab3bb1a920" title="tinyformat::printfln" alt="" coords="2079,746,2225,773"/>
<area shape="rect" id="node10" href="namespacetinyformat_1_1detail.html#ad3d636b9f85202b515c8940b7fcb62a6" title="tinyformat::detail\l::printFormatStringLiteral" alt="" coords="2304,564,2489,605"/>
<area shape="rect" id="node11" href="namespacetinyformat_1_1detail.html#ab4493739cbfe66bc79867f13f1fdf0db" title="tinyformat::detail\l::streamStateFromFormat" alt="" coords="2303,629,2491,671"/>
<area shape="rect" id="node15" href="classtinyformat_1_1detail_1_1_format_arg.html#acbf435711bbe4a4da7fc81758d7108a9" title="tinyformat::detail\l::FormatArg::format" alt="" coords="2321,695,2472,736"/>
<area shape="rect" id="node12" href="namespacetinyformat_1_1detail.html#a67285e0adb9f4164f9fc30a3eb11c771" title="tinyformat::detail\l::parseIntAndAdvance" alt="" coords="2765,600,2929,641"/>
<area shape="rect" id="node13" href="namespacetinyformat_1_1detail.html#ae1e94cbdd9e7cf26f17856a1792664e1" title="tinyformat::detail\l::parseWidthOrPrecision" alt="" coords="2539,659,2717,700"/>
<area shape="rect" id="node14" href="classtinyformat_1_1detail_1_1_format_arg.html#a91b69f66ce9dc8ca2914dce8985d7a1a" title="tinyformat::detail\l::FormatArg::toInt" alt="" coords="2779,665,2915,707"/>
<area shape="rect" id="node20" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35" title="Returns the relation with the given name in the program. " alt="" coords="664,613,840,639"/>
<area shape="rect" id="node24" href="classsouffle_1_1ast_1_1_relation.html#a4f64acf8983db2fb8ba59c9273c1cf20" title="Check for a relation qualifier. " alt="" coords="449,433,603,475"/>
<area shape="rect" id="node25" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="665,789,839,815"/>
<area shape="rect" id="node27" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23" title="Inlines the given atom based on a given clause. " alt="" coords="669,431,835,472"/>
<area shape="rect" id="node34" href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd" title="Returns a vector of atoms that should replace the given atom after one step of inlining. " alt="" coords="669,365,835,407"/>
<area shape="rect" id="node37" href="namespacesouffle_1_1ast_1_1transform.html#a8a7455cc2262cc907c15e6124ac6588a" title="Forms the bodies that will replace the negation of a given inlined atom. " alt="" coords="443,551,609,592"/>
<area shape="rect" id="node21" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="940,671,1044,698"/>
<area shape="rect" id="node22" href="classsouffle_1_1ast_1_1_program.html#a89bc64ed82fbb346ff8fcb922386c196" title="Return relations. " alt="" coords="1166,889,1323,931"/>
<area shape="rect" id="node23" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1433,897,1579,923"/>
<area shape="rect" id="node26" href="classsouffle_1_1ast_1_1_program.html#a529839d448f4139ce2e4e87bcfe3201f" title="Return clauses. " alt="" coords="1166,955,1323,996"/>
<area shape="rect" id="node28" href="namespacesouffle_1_1ast_1_1transform.html#a4ef7394d84d020c597cb916fa67ff8ed" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="909,488,1075,529"/>
<area shape="rect" id="node29" href="classsouffle_1_1ast_1_1_atom.html#a48b2afc7e3e22611a93b42f0089342d8" title="Return arguments. " alt="" coords="1176,696,1313,737"/>
<area shape="rect" id="node30" href="namespacesouffle_1_1ast_1_1transform.html#aef0f3b772710ab151915d04c2538070e" title="Reduces a vector of substitutions. " alt="" coords="1161,513,1328,555"/>
<area shape="rect" id="node31" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1" title="A generic factory for constraints of the form. " alt="" coords="1413,521,1599,547"/>
<area shape="rect" id="node35" href="classsouffle_1_1ast_1_1_atom.html#ab9a22c7f862012f074559a4061696241" title="Return qualified name. " alt="" coords="918,605,1066,647"/>
<area shape="rect" id="node36" href="classsouffle_1_1ast_1_1_node.html#ac87a64ccec4ee0e470effeef0c6f3a0b" title="Return source location of the Node. " alt="" coords="1438,455,1574,496"/>
<area shape="rect" id="node38" href="namespacesouffle_1_1ast_1_1transform.html#a146c65e4e8a4429da50a66c746744e58" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="657,496,847,537"/>
<area shape="rect" id="node39" href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d" title="Returns the negated version of a given literal. " alt="" coords="909,423,1075,464"/>
<area shape="rect" id="node40" href="classsouffle_1_1ast_1_1_atom.html#a25ad407a2a6ec36e21062d70ff74b24b" title="Create a clone (i.e. " alt="" coords="1176,396,1313,437"/>
<area shape="rect" id="node42" href="namespacesouffle_1_1ast.html#aa858fc1ad141e8a9dd2b806407c65116" title="Negate an ast constraint. " alt="" coords="1137,579,1352,620"/>
<area shape="rect" id="node41" href="classsouffle_1_1ast_1_1_atom.html#a62f0d1457357894e5553a98a9df0deaf" title="souffle::ast::Atom\l::Atom" alt="" coords="1437,389,1575,431"/>
<area shape="rect" id="node43" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="1400,586,1612,613"/>
</map>
</div>

</div>
</div>
<a id="addbf430b3cb758d9345bb1ba0dd17efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbf430b3cb758d9345bb1ba0dd17efd">&#9670;&nbsp;</a></span>getInlinedAtom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt;<a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a>*&gt; souffle::ast::transform::getInlinedAtom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> &amp;&#160;</td>
          <td class="paramname"><em>atom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of atoms that should replace the given atom after one step of inlining. </p>
<p>Assumes the relation the atom belongs to is not inlined itself. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00719">719</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="_container_util_8h_source.html#l00166">souffle::clone()</a>, <a class="el" href="_atom_8h_source.html#l00071">souffle::ast::Atom::getArguments()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00534">getInlinedArgument()</a>, <a class="el" href="_atom_8h_source.html#l00051">souffle::ast::Atom::getQualifiedName()</a>, <a class="el" href="ast_2_node_8h_source.html#l00040">souffle::ast::Node::getSrcLoc()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00075">souffle::ast::transform::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="json11_8h_source.html#l00663">i</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00071">souffle::ast::transform::NullableVector&lt; T &gt;::isValid()</a>, and <a class="el" href="html_js_chartist_min_8h_source.html#l00015">j</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00901">getInlinedClause()</a>, and <a class="el" href="_inline_relations_8cpp_source.html#l00775">getInlinedLiteral()</a>.</p>
<div class="fragment"><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;                                                                   {</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;    std::vector&lt;Atom*&gt; versions;</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;    <span class="comment">// Try to inline each of the atom&#39;s arguments</span></div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;    std::vector&lt;Argument*&gt; arguments = atom.getArguments();</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; arguments.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;        Argument* arg = arguments[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;        NullableVector&lt;Argument*&gt; argumentVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a>(program, arg);</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;        <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;            <span class="comment">// Argument has replacements</span></div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;            changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;            <span class="comment">// Create a new atom per new version of the argument</span></div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;            <span class="keywordflow">for</span> (Argument* newArgument : argumentVersions.getVector()) {</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;                <span class="keyword">auto</span> args = atom.getArguments();</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;                VecOwn&lt;Argument&gt; newArgs;</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = 0; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> &lt; args.size(); <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>++) {</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;                    <span class="keywordflow">if</span> (<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> == <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>) {</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;                        newArgs.emplace_back(newArgument);</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;                    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;                        newArgs.emplace_back(args[<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>]-&gt;<a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">clone</a>());</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;                    }</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;                }</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;                <span class="keyword">auto</span>* newAtom = <span class="keyword">new</span> Atom(atom.getQualifiedName(), std::move(newArgs), atom.getSrcLoc());</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;                versions.push_back(newAtom);</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;            }</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;        }</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;        <span class="comment">// Only perform one stage of inlining at a time.</span></div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;        <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;        }</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;    }</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;    <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;        <span class="comment">// Return a valid vector - replacements need to be made!</span></div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;Atom*&gt;(versions);</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;        <span class="comment">// Return an invalid vector - no replacements need to be made</span></div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;Atom*&gt;();</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;    }</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a1dd578fbaf92e67ee52ebdd8cf364584"><div class="ttname"><a href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a></div><div class="ttdeci">auto clone(const std::vector&lt; A *&gt; &amp;xs)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00166">ContainerUtil.h:166</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00663">json11.h:663</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_aab858032a95af802114b255fac6f45f2"><div class="ttname"><a href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a></div><div class="ttdeci">var j</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_ac78e04494a4e67eb9ae63a399c99d92f"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">souffle::ast::transform::getInlinedArgument</a></div><div class="ttdeci">NullableVector&lt; Argument * &gt; getInlinedArgument(Program &amp;program, const Argument *arg)</div><div class="ttdoc">Returns a vector of arguments that should replace the given argument after one step of inlining...</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00534">InlineRelations.cpp:534</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_addbf430b3cb758d9345bb1ba0dd17efd_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_addbf430b3cb758d9345bb1ba0dd17efd_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_addbf430b3cb758d9345bb1ba0dd17efd_cgraph" id="namespacesouffle_1_1ast_1_1transform_addbf430b3cb758d9345bb1ba0dd17efd_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584" title="souffle::clone" alt="" coords="1666,261,1775,288"/>
<area shape="rect" id="node3" href="classsouffle_1_1ast_1_1_atom.html#a48b2afc7e3e22611a93b42f0089342d8" title="Return arguments. " alt="" coords="1391,1069,1528,1110"/>
<area shape="rect" id="node5" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f" title="Returns a vector of arguments that should replace the given argument after one step of inlining..." alt="" coords="220,458,387,499"/>
<area shape="rect" id="node33" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html#a9603290d354fffc43865cb122b514abf" title="souffle::ast::transform\l::NullableVector::isValid" alt="" coords="1119,334,1295,375"/>
<area shape="rect" id="node34" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html#ab1413c473cb705a7ce19d8e2bafa2509" title="souffle::ast::transform\l::NullableVector::getVector" alt="" coords="1109,637,1304,678"/>
<area shape="rect" id="node40" href="classsouffle_1_1ast_1_1_node.html#ac87a64ccec4ee0e470effeef0c6f3a0b" title="Return source location of the Node. " alt="" coords="1653,786,1789,827"/>
<area shape="rect" id="node43" href="classsouffle_1_1ast_1_1_atom.html#ab9a22c7f862012f074559a4061696241" title="Return qualified name. " alt="" coords="893,977,1041,1018"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1647,1011,1794,1037"/>
<area shape="rect" id="node6" href="namespacesouffle_1_1ast_1_1transform.html#ac08b034edc612cbd02a263082b1bbc46" title="souffle::ast::transform\l::combineAggregators" alt="" coords="439,170,605,211"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a315141918c39611929a694840f046fb5" title="souffle::fatal" alt="" coords="1669,592,1773,619"/>
<area shape="rect" id="node22" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e" title="Tries to perform a single step of inlining on the given literal. " alt="" coords="439,621,605,662"/>
<area shape="rect" id="node44" href="classsouffle_1_1ast_1_1_aggregator.html#a89b1301ec904219812c93d5eb62b2c3e" title="Set body. " alt="" coords="435,429,609,470"/>
<area shape="rect" id="node45" href="classsouffle_1_1ast_1_1_node.html#a8eab0e38c9a5343d641d5b2eb631733a" title="Set source location for the Node. " alt="" coords="454,363,590,405"/>
<area shape="rect" id="node7" href="namespacesouffle_1_1ast_1_1transform.html#a1211fcf1fa30273559973f585502c936" title="Renames all variables in a given argument uniquely. " alt="" coords="657,145,824,186"/>
<area shape="rect" id="node8" href="classsouffle_1_1ast_1_1_node.html#a40bbdb53c63f664c2c43854dc7f0af7b" title="Apply the mapper to all child nodes. " alt="" coords="899,145,1035,186"/>
<area shape="rect" id="node10" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61" title="tinyformat::format" alt="" coords="1875,592,2017,619"/>
<area shape="rect" id="node11" href="namespacetinyformat.html#a86ed74eb3ed66a662e96220d877da964" title="Format list of arguments to the stream according to the given format string. " alt="" coords="2065,592,2216,619"/>
<area shape="rect" id="node19" href="namespacetinyformat.html#ab7b10973ec89e6601353675a85f99d61" title="tinyformat::makeFormatList" alt="" coords="2264,525,2469,552"/>
<area shape="rect" id="node12" href="namespacetinyformat_1_1detail.html#a9fe547bc617c38498e58c12cce507bec" title="tinyformat::detail\l::formatImpl" alt="" coords="2299,577,2435,618"/>
<area shape="rect" id="node20" href="namespacetinyformat.html#a970fd8292e14eb74ba55bafb41017016" title="tinyformat::printf" alt="" coords="2299,643,2434,669"/>
<area shape="rect" id="node21" href="namespacetinyformat.html#a97775445fea05ffaaa0690ab3bb1a920" title="tinyformat::printfln" alt="" coords="2294,693,2439,720"/>
<area shape="rect" id="node13" href="namespacetinyformat_1_1detail.html#ad3d636b9f85202b515c8940b7fcb62a6" title="tinyformat::detail\l::printFormatStringLiteral" alt="" coords="2519,511,2704,553"/>
<area shape="rect" id="node14" href="namespacetinyformat_1_1detail.html#ab4493739cbfe66bc79867f13f1fdf0db" title="tinyformat::detail\l::streamStateFromFormat" alt="" coords="2517,577,2705,618"/>
<area shape="rect" id="node18" href="classtinyformat_1_1detail_1_1_format_arg.html#acbf435711bbe4a4da7fc81758d7108a9" title="tinyformat::detail\l::FormatArg::format" alt="" coords="2536,642,2687,683"/>
<area shape="rect" id="node15" href="namespacetinyformat_1_1detail.html#a67285e0adb9f4164f9fc30a3eb11c771" title="tinyformat::detail\l::parseIntAndAdvance" alt="" coords="2980,547,3144,589"/>
<area shape="rect" id="node16" href="namespacetinyformat_1_1detail.html#ae1e94cbdd9e7cf26f17856a1792664e1" title="tinyformat::detail\l::parseWidthOrPrecision" alt="" coords="2753,606,2932,647"/>
<area shape="rect" id="node17" href="classtinyformat_1_1detail_1_1_format_arg.html#a91b69f66ce9dc8ca2914dce8985d7a1a" title="tinyformat::detail\l::FormatArg::toInt" alt="" coords="2994,613,3130,654"/>
<area shape="rect" id="node23" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35" title="Returns the relation with the given name in the program. " alt="" coords="879,925,1055,952"/>
<area shape="rect" id="node26" href="classsouffle_1_1ast_1_1_relation.html#a4f64acf8983db2fb8ba59c9273c1cf20" title="Check for a relation qualifier. " alt="" coords="663,691,818,733"/>
<area shape="rect" id="node27" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="879,875,1054,901"/>
<area shape="rect" id="node29" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23" title="Inlines the given atom based on a given clause. " alt="" coords="883,566,1050,607"/>
<area shape="rect" id="node35" href="namespacesouffle_1_1ast_1_1transform.html#a8a7455cc2262cc907c15e6124ac6588a" title="Forms the bodies that will replace the negation of a given inlined atom. " alt="" coords="657,809,824,850"/>
<area shape="rect" id="node24" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1155,968,1259,995"/>
<area shape="rect" id="node25" href="classsouffle_1_1ast_1_1_program.html#a89bc64ed82fbb346ff8fcb922386c196" title="Return relations. " alt="" coords="1381,1003,1538,1045"/>
<area shape="rect" id="node28" href="classsouffle_1_1ast_1_1_program.html#a529839d448f4139ce2e4e87bcfe3201f" title="Return clauses. " alt="" coords="1381,923,1538,965"/>
<area shape="rect" id="node30" href="namespacesouffle_1_1ast_1_1transform.html#a4ef7394d84d020c597cb916fa67ff8ed" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="1123,851,1290,893"/>
<area shape="rect" id="node31" href="namespacesouffle_1_1ast_1_1transform.html#aef0f3b772710ab151915d04c2538070e" title="Reduces a vector of substitutions. " alt="" coords="1376,851,1543,893"/>
<area shape="rect" id="node32" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1" title="A generic factory for constraints of the form. " alt="" coords="1627,859,1814,885"/>
<area shape="rect" id="node36" href="namespacesouffle_1_1ast_1_1transform.html#a146c65e4e8a4429da50a66c746744e58" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="872,809,1061,850"/>
<area shape="rect" id="node37" href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d" title="Returns the negated version of a given literal. " alt="" coords="1123,702,1290,743"/>
<area shape="rect" id="node38" href="classsouffle_1_1ast_1_1_atom.html#a25ad407a2a6ec36e21062d70ff74b24b" title="Create a clone (i.e. " alt="" coords="1391,709,1528,750"/>
<area shape="rect" id="node41" href="namespacesouffle_1_1ast.html#aa858fc1ad141e8a9dd2b806407c65116" title="Negate an ast constraint. " alt="" coords="1352,643,1567,685"/>
<area shape="rect" id="node39" href="classsouffle_1_1ast_1_1_atom.html#a62f0d1457357894e5553a98a9df0deaf" title="souffle::ast::Atom\l::Atom" alt="" coords="1652,709,1789,750"/>
<area shape="rect" id="node42" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="1615,651,1827,677"/>
</map>
</div>

</div>
</div>
<a id="a0249ff1a6616f955f319df5ffdfaae41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0249ff1a6616f955f319df5ffdfaae41">&#9670;&nbsp;</a></span>getInlinedClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a>*&gt; souffle::ast::transform::getInlinedClause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of clauses that should replace the given clause after one step of inlining. </p>
<p>If no inlining can occur, the list will only contain a clone of the original clause. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00901">901</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="_clause_8h_source.html#l00053">souffle::ast::Clause::addToBody()</a>, <a class="el" href="_clause_8h_source.html#l00092">souffle::ast::Clause::clone()</a>, <a class="el" href="_container_util_8h_source.html#l00166">souffle::clone()</a>, <a class="el" href="_utils_8cpp_source.html#l00241">souffle::ast::cloneHead()</a>, <a class="el" href="_clause_8h_source.html#l00073">souffle::ast::Clause::getBodyLiterals()</a>, <a class="el" href="_clause_8h_source.html#l00068">souffle::ast::Clause::getHead()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00719">getInlinedAtom()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00775">getInlinedLiteral()</a>, <a class="el" href="ast_2_node_8h_source.html#l00040">souffle::ast::Node::getSrcLoc()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00075">souffle::ast::transform::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="json11_8h_source.html#l00663">i</a>, and <a class="el" href="_inline_relations_8cpp_source.html#l00071">souffle::ast::transform::NullableVector&lt; T &gt;::isValid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00992">souffle::ast::transform::InlineRelationsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;                                                                            {</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;    std::vector&lt;Clause*&gt; versions;</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;    <span class="comment">// Try to inline things contained in the arguments of the head first.</span></div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;    <span class="comment">// E.g. `a(x, max y : { b(y) }) :- c(x).`, where b should be inlined.</span></div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;    Atom* head = clause.getHead();</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;    NullableVector&lt;Atom*&gt; headVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd">getInlinedAtom</a>(program, *head);</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;    <span class="keywordflow">if</span> (headVersions.isValid()) {</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;        <span class="comment">// The head atom can be inlined!</span></div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;        changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;        <span class="comment">// Produce the new clauses with the replacement head atoms</span></div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;        <span class="keywordflow">for</span> (Atom* newHead : headVersions.getVector()) {</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;            <span class="keyword">auto</span>* newClause = <span class="keyword">new</span> Clause();</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;            newClause-&gt;setSrcLoc(clause.getSrcLoc());</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;            newClause-&gt;setHead(Own&lt;Atom&gt;(newHead));</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;            <span class="comment">// The body will remain unchanged</span></div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;            <span class="keywordflow">for</span> (Literal* lit : clause.getBodyLiterals()) {</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;                newClause-&gt;addToBody(<a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(lit));</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;            }</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;            versions.push_back(newClause);</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;        }</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;    }</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;    <span class="comment">// Only perform one stage of inlining at a time.</span></div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;    <span class="comment">// If the head atoms did not need inlining, try inlining atoms nested in the body.</span></div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;    <span class="keywordflow">if</span> (!changed) {</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;        std::vector&lt;Literal*&gt; bodyLiterals = clause.getBodyLiterals();</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; bodyLiterals.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;            Literal* currLit = bodyLiterals[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;            <span class="comment">// Three possible cases when trying to inline a literal:</span></div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;            <span class="comment">//  1) The literal itself may be directly inlined. In this case, the atom can be replaced</span></div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;            <span class="comment">//    with multiple different bodies, as the inlined atom may have several rules.</span></div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;            <span class="comment">//  2) Otherwise, the literal itself may not need to be inlined, but a subnode (e.g. an argument)</span></div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;            <span class="comment">//    may need to be inlined. In this case, an altered literal must replace the original.</span></div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;            <span class="comment">//    Again, several possible versions may exist, as the inlined relation may have several rules.</span></div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;            <span class="comment">//  3) The literal does not depend on any inlined relations, and so does not need to be changed.</span></div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;            NullableVector&lt;std::vector&lt;Literal*&gt;&gt; litVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e">getInlinedLiteral</a>(program, currLit);</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;            <span class="keywordflow">if</span> (litVersions.isValid()) {</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;                <span class="comment">// Case 1 and 2: Inlining has occurred!</span></div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;                changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;                <span class="comment">// The literal may be replaced with several different bodies.</span></div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;                <span class="comment">// Create a new clause for each possible version.</span></div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;                std::vector&lt;std::vector&lt;Literal*&gt;&gt; bodyVersions = litVersions.getVector();</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;                <span class="comment">// Create the base clause with the current literal removed</span></div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;                <span class="keyword">auto</span> baseClause = Own&lt;Clause&gt;(<a class="code" href="namespacesouffle_1_1ast.html#a29de8c1720372f7c78dcfabe84767118">cloneHead</a>(&amp;clause));</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;                <span class="keywordflow">for</span> (Literal* oldLit : bodyLiterals) {</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;                    <span class="keywordflow">if</span> (currLit != oldLit) {</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;                        baseClause-&gt;addToBody(<a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(oldLit));</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;                    }</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;                }</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;                <span class="keywordflow">for</span> (std::vector&lt;Literal*&gt; body : bodyVersions) {</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;                    Clause* replacementClause = baseClause-&gt;clone();</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;                    <span class="comment">// Add in the current set of literals replacing the inlined literal</span></div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;                    <span class="comment">// In Case 2, each body contains exactly one literal</span></div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;                    <span class="keywordflow">for</span> (Literal* newLit : body) {</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;                        replacementClause-&gt;addToBody(Own&lt;Literal&gt;(newLit));</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;                    }</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;                    versions.push_back(replacementClause);</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;                }</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;            }</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;            <span class="comment">// Only replace at most one literal per iteration</span></div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;            <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;            }</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;        }</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;    }</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;    <span class="keywordflow">if</span> (!changed) {</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;        <span class="comment">// Case 3: No inlining changes, so a clone of the original should be returned</span></div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;        std::vector&lt;Clause*&gt; ret;</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;        ret.push_back(clause.clone());</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;        <span class="keywordflow">return</span> ret;</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;        <span class="comment">// Inlining changes, so return the replacement clauses.</span></div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;        <span class="keywordflow">return</span> versions;</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;    }</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a1dd578fbaf92e67ee52ebdd8cf364584"><div class="ttname"><a href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a></div><div class="ttdeci">auto clone(const std::vector&lt; A *&gt; &amp;xs)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00166">ContainerUtil.h:166</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_html_a29de8c1720372f7c78dcfabe84767118"><div class="ttname"><a href="namespacesouffle_1_1ast.html#a29de8c1720372f7c78dcfabe84767118">souffle::ast::cloneHead</a></div><div class="ttdeci">Clause * cloneHead(const Clause *clause)</div><div class="ttdoc">Returns a clause which contains head of the given clause. </div><div class="ttdef"><b>Definition:</b> <a href="_utils_8cpp_source.html#l00241">Utils.cpp:241</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00663">json11.h:663</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_a60d908235c9c6d168bdfb2098b55090e"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e">souffle::ast::transform::getInlinedLiteral</a></div><div class="ttdeci">NullableVector&lt; std::vector&lt; Literal * &gt; &gt; getInlinedLiteral(Program &amp;, Literal *)</div><div class="ttdoc">Tries to perform a single step of inlining on the given literal. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00775">InlineRelations.cpp:775</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_addbf430b3cb758d9345bb1ba0dd17efd"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd">souffle::ast::transform::getInlinedAtom</a></div><div class="ttdeci">NullableVector&lt; Atom * &gt; getInlinedAtom(Program &amp;program, Atom &amp;atom)</div><div class="ttdoc">Returns a vector of atoms that should replace the given atom after one step of inlining. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00719">InlineRelations.cpp:719</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_a0249ff1a6616f955f319df5ffdfaae41_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_a0249ff1a6616f955f319df5ffdfaae41_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_a0249ff1a6616f955f319df5ffdfaae41_cgraph" id="namespacesouffle_1_1ast_1_1transform_a0249ff1a6616f955f319df5ffdfaae41_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1ast_1_1_clause.html#a7d36da64e75437f63fcaea9b5bdba5e8" title="Add a literal to the body of the clause. " alt="" coords="232,5,379,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1ast_1_1_clause.html#a559bfba3b467f0512a9e292e250c30c1" title="Create a clone (i.e. " alt="" coords="1605,56,1751,97"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584" title="souffle::clone" alt="" coords="1885,594,1994,621"/>
<area shape="rect" id="node8" href="classsouffle_1_1ast_1_1_node.html#ac87a64ccec4ee0e470effeef0c6f3a0b" title="Return source location of the Node. " alt="" coords="1871,165,2007,207"/>
<area shape="rect" id="node9" href="namespacesouffle_1_1ast.html#a29de8c1720372f7c78dcfabe84767118" title="Returns a clause which contains head of the given clause. " alt="" coords="220,290,391,317"/>
<area shape="rect" id="node11" href="classsouffle_1_1ast_1_1_clause.html#a92a6ca9ea20fe63f074d597d81d07c08" title="Return the atom that represents the head of the clause. " alt="" coords="449,341,595,383"/>
<area shape="rect" id="node12" href="classsouffle_1_1ast_1_1_clause.html#a199bb0fc53e3f9980967d67b8dfb68a5" title="Obtains a copy of the internally maintained body literals. " alt="" coords="449,1644,595,1685"/>
<area shape="rect" id="node14" href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd" title="Returns a vector of atoms that should replace the given atom after one step of inlining. " alt="" coords="222,936,389,977"/>
<area shape="rect" id="node28" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e" title="Tries to perform a single step of inlining on the given literal. " alt="" coords="657,1037,824,1079"/>
<area shape="rect" id="node39" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html#a9603290d354fffc43865cb122b514abf" title="souffle::ast::transform\l::NullableVector::isValid" alt="" coords="1337,628,1513,669"/>
<area shape="rect" id="node40" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html#ab1413c473cb705a7ce19d8e2bafa2509" title="souffle::ast::transform\l::NullableVector::getVector" alt="" coords="1328,1253,1523,1295"/>
<area shape="rect" id="node4" href="classsouffle_1_1ast_1_1_clause.html#a8f9e7d317c2b0082e72ef4357e01dd00" title="souffle::ast::Clause\l::Clause" alt="" coords="1866,56,2013,97"/>
<area shape="rect" id="node5" href="classsouffle_1_1ast_1_1_node.html#a2317760f042742653d90496a6d4dfa2d" title="souffle::ast::Node\l::Node" alt="" coords="2097,56,2233,97"/>
<area shape="rect" id="node6" href="classsouffle_1_1ast_1_1_node.html#ab6ffbc606765b82b0c511df3760e642b" title="souffle::ast::Node\l::~Node" alt="" coords="2291,56,2427,97"/>
<area shape="rect" id="node10" href="classsouffle_1_1ast_1_1_clause.html#aa14e0157716ca749fd1416c597f2f839" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="449,224,595,265"/>
<area shape="rect" id="node13" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1866,1299,2013,1326"/>
<area shape="rect" id="node15" href="classsouffle_1_1ast_1_1_atom.html#a48b2afc7e3e22611a93b42f0089342d8" title="Return arguments. " alt="" coords="1609,1197,1747,1239"/>
<area shape="rect" id="node16" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f" title="Returns a vector of arguments that should replace the given argument after one step of inlining..." alt="" coords="439,856,605,897"/>
<area shape="rect" id="node48" href="classsouffle_1_1ast_1_1_atom.html#ab9a22c7f862012f074559a4061696241" title="Return qualified name. " alt="" coords="1111,1375,1259,1416"/>
<area shape="rect" id="node17" href="namespacesouffle_1_1ast_1_1transform.html#ac08b034edc612cbd02a263082b1bbc46" title="souffle::ast::transform\l::combineAggregators" alt="" coords="657,711,824,752"/>
<area shape="rect" id="node20" href="namespacesouffle.html#a315141918c39611929a694840f046fb5" title="souffle::fatal" alt="" coords="1887,1030,1991,1057"/>
<area shape="rect" id="node49" href="classsouffle_1_1ast_1_1_aggregator.html#a89b1301ec904219812c93d5eb62b2c3e" title="Set body. " alt="" coords="653,776,828,817"/>
<area shape="rect" id="node50" href="classsouffle_1_1ast_1_1_node.html#a8eab0e38c9a5343d641d5b2eb631733a" title="Set source location for the Node. " alt="" coords="673,645,809,687"/>
<area shape="rect" id="node18" href="namespacesouffle_1_1ast_1_1transform.html#a1211fcf1fa30273559973f585502c936" title="Renames all variables in a given argument uniquely. " alt="" coords="876,645,1043,687"/>
<area shape="rect" id="node19" href="classsouffle_1_1ast_1_1_node.html#a40bbdb53c63f664c2c43854dc7f0af7b" title="Apply the mapper to all child nodes. " alt="" coords="1117,645,1253,687"/>
<area shape="rect" id="node21" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61" title="tinyformat::format" alt="" coords="2093,1030,2236,1057"/>
<area shape="rect" id="node22" href="namespacetinyformat.html#a86ed74eb3ed66a662e96220d877da964" title="Format list of arguments to the stream according to the given format string. " alt="" coords="2284,1030,2435,1057"/>
<area shape="rect" id="node25" href="namespacetinyformat.html#ab7b10973ec89e6601353675a85f99d61" title="tinyformat::makeFormatList" alt="" coords="2483,979,2688,1006"/>
<area shape="rect" id="node23" href="namespacetinyformat_1_1detail.html#a9fe547bc617c38498e58c12cce507bec" title="tinyformat::detail\l::formatImpl" alt="" coords="2517,1031,2653,1072"/>
<area shape="rect" id="node26" href="namespacetinyformat.html#a970fd8292e14eb74ba55bafb41017016" title="tinyformat::printf" alt="" coords="2518,1097,2653,1123"/>
<area shape="rect" id="node27" href="namespacetinyformat.html#a97775445fea05ffaaa0690ab3bb1a920" title="tinyformat::printfln" alt="" coords="2513,929,2658,955"/>
<area shape="rect" id="node24" href="namespacetinyformat_1_1detail.html#ad3d636b9f85202b515c8940b7fcb62a6" title="tinyformat::detail\l::printFormatStringLiteral" alt="" coords="2736,1031,2921,1072"/>
<area shape="rect" id="node29" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35" title="Returns the relation with the given name in the program. " alt="" coords="1097,1147,1273,1174"/>
<area shape="rect" id="node32" href="classsouffle_1_1ast_1_1_relation.html#a4f64acf8983db2fb8ba59c9273c1cf20" title="Check for a relation qualifier. " alt="" coords="882,1016,1037,1057"/>
<area shape="rect" id="node33" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="1098,1323,1273,1350"/>
<area shape="rect" id="node35" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23" title="Inlines the given atom based on a given clause. " alt="" coords="1102,1016,1269,1057"/>
<area shape="rect" id="node41" href="namespacesouffle_1_1ast_1_1transform.html#a8a7455cc2262cc907c15e6124ac6588a" title="Forms the bodies that will replace the negation of a given inlined atom. " alt="" coords="876,1133,1043,1175"/>
<area shape="rect" id="node30" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1373,1149,1477,1175"/>
<area shape="rect" id="node31" href="classsouffle_1_1ast_1_1_program.html#a89bc64ed82fbb346ff8fcb922386c196" title="Return relations. " alt="" coords="1599,1263,1757,1304"/>
<area shape="rect" id="node34" href="classsouffle_1_1ast_1_1_program.html#a529839d448f4139ce2e4e87bcfe3201f" title="Return clauses. " alt="" coords="1347,1320,1504,1361"/>
<area shape="rect" id="node36" href="namespacesouffle_1_1ast_1_1transform.html#a4ef7394d84d020c597cb916fa67ff8ed" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="1342,1083,1509,1124"/>
<area shape="rect" id="node37" href="namespacesouffle_1_1ast_1_1transform.html#aef0f3b772710ab151915d04c2538070e" title="Reduces a vector of substitutions. " alt="" coords="1595,1132,1761,1173"/>
<area shape="rect" id="node38" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1" title="A generic factory for constraints of the form. " alt="" coords="1846,1139,2033,1166"/>
<area shape="rect" id="node42" href="namespacesouffle_1_1ast_1_1transform.html#a146c65e4e8a4429da50a66c746744e58" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="1091,1081,1280,1123"/>
<area shape="rect" id="node43" href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d" title="Returns the negated version of a given literal. " alt="" coords="1342,964,1509,1005"/>
<area shape="rect" id="node44" href="classsouffle_1_1ast_1_1_atom.html#a25ad407a2a6ec36e21062d70ff74b24b" title="Create a clone (i.e. " alt="" coords="1609,847,1747,888"/>
<area shape="rect" id="node46" href="namespacesouffle_1_1ast.html#aa858fc1ad141e8a9dd2b806407c65116" title="Negate an ast constraint. " alt="" coords="1571,964,1785,1005"/>
<area shape="rect" id="node45" href="classsouffle_1_1ast_1_1_atom.html#a62f0d1457357894e5553a98a9df0deaf" title="souffle::ast::Atom\l::Atom" alt="" coords="1871,847,2008,888"/>
<area shape="rect" id="node47" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="1833,971,2045,998"/>
</map>
</div>

</div>
</div>
<a id="a60d908235c9c6d168bdfb2098b55090e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d908235c9c6d168bdfb2098b55090e">&#9670;&nbsp;</a></span>getInlinedLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt; std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> * &gt; &gt; souffle::ast::transform::getInlinedLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> *&#160;</td>
          <td class="paramname"><em>lit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to perform a single step of inlining on the given literal. </p>
<p>Returns a pair of nullable vectors (v, w) such that:</p><ul>
<li>v is valid if and only if the literal can be directly inlined, whereby it contains the bodies that replace it</li>
<li>if v is not valid, then w is valid if and only if the literal cannot be inlined directly, but contains a subargument that can be. In this case, it will contain the versions that will replace it.</li>
<li>If both are invalid, then no more inlining can occur on this literal and we are done. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00775">775</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="_container_util_8h_source.html#l00166">souffle::clone()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00431">formNegatedLiterals()</a>, <a class="el" href="_utils_8cpp_source.html#l00070">souffle::ast::getClauses()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00534">getInlinedArgument()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00719">getInlinedAtom()</a>, <a class="el" href="_utils_8cpp_source.html#l00094">souffle::ast::getRelation()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00075">souffle::ast::transform::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="ast_2_relation_8h_source.html#l00107">souffle::ast::Relation::hasQualifier()</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">souffle::INLINE</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00295">inlineBodyLiterals()</a>, and <a class="el" href="_inline_relations_8cpp_source.html#l00071">souffle::ast::transform::NullableVector&lt; T &gt;::isValid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00534">getInlinedArgument()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00901">getInlinedClause()</a>, and <a class="el" href="_inline_relations_8cpp_source.html#l00075">souffle::ast::transform::NullableVector&lt; T &gt;::getVector()</a>.</p>
<div class="fragment"><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;                                                                                      {</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;    <span class="keywordtype">bool</span> inlined = <span class="keyword">false</span>;</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;    std::vector&lt;std::vector&lt;Literal*&gt;&gt; addedBodyLiterals;</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;    std::vector&lt;Literal*&gt; versions;</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span>* atom = dynamic_cast&lt;Atom*&gt;(lit)) {</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;        <span class="comment">// Check if this atom is meant to be inlined</span></div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;        Relation* rel = <a class="code" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35">getRelation</a>(program, atom-&gt;getQualifiedName());</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;        <span class="keywordflow">if</span> (rel-&gt;hasQualifier(RelationQualifier::INLINE)) {</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;            <span class="comment">// We found an atom in the clause that needs to be inlined!</span></div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;            <span class="comment">// The clause needs to be replaced</span></div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;            inlined = <span class="keyword">true</span>;</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;            <span class="comment">// N new clauses should be formed, where N is the number of clauses</span></div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;            <span class="comment">// associated with the inlined relation</span></div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;            <span class="keywordflow">for</span> (Clause* inClause : <a class="code" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f">getClauses</a>(program, *rel)) {</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;                <span class="comment">// Form the replacement clause</span></div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;                std::pair&lt;NullableVector&lt;Literal*&gt;, std::vector&lt;BinaryConstraint*&gt;&gt; inlineResult =</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;                        <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23">inlineBodyLiterals</a>(atom, inClause);</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;                NullableVector&lt;Literal*&gt; replacementBodyLiterals = inlineResult.first;</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;                std::vector&lt;BinaryConstraint*&gt; currConstraints = inlineResult.second;</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;                <span class="keywordflow">if</span> (!replacementBodyLiterals.isValid()) {</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;                    <span class="comment">// Failed to unify the atoms! We can skip this one...</span></div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;                }</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;                <span class="comment">// Unification successful - the returned vector of literals represents one possible body</span></div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;                <span class="comment">// replacement We can add in the unification constraints as part of these literals.</span></div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;                std::vector&lt;Literal*&gt; bodyResult = replacementBodyLiterals.getVector();</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;                <span class="keywordflow">for</span> (BinaryConstraint* cons : currConstraints) {</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;                    bodyResult.push_back(cons);</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;                }</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;                addedBodyLiterals.push_back(bodyResult);</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;            }</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;            <span class="comment">// Not meant to be inlined, but a subargument may be</span></div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;            NullableVector&lt;Atom*&gt; atomVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd">getInlinedAtom</a>(program, *atom);</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;            <span class="keywordflow">if</span> (atomVersions.isValid()) {</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;                <span class="comment">// Subnode needs to be inlined, so we have a vector of replacement atoms</span></div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;                changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;                <span class="keywordflow">for</span> (Atom* newAtom : atomVersions.getVector()) {</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;                    versions.push_back(newAtom);</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;                }</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;            }</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;        }</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span> neg = dynamic_cast&lt;Negation*&gt;(lit)) {</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;        <span class="comment">// For negations, check the corresponding atom</span></div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;        Atom* atom = neg-&gt;getAtom();</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;        NullableVector&lt;std::vector&lt;Literal*&gt;&gt; atomVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e">getInlinedLiteral</a>(program, atom);</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;        <span class="keywordflow">if</span> (atomVersions.isValid()) {</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;            <span class="comment">// The atom can be inlined</span></div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;            inlined = <span class="keyword">true</span>;</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;            <span class="keywordflow">if</span> (atomVersions.getVector().empty()) {</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;                <span class="comment">// No clauses associated with the atom, so just becomes a true literal</span></div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;                addedBodyLiterals.push_back({<span class="keyword">new</span> BooleanConstraint(<span class="keyword">true</span>)});</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;                <span class="comment">// Suppose an atom a(x) is inlined and has the following rules:</span></div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;                <span class="comment">//  - a(x) :- a11(x), a12(x).</span></div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;                <span class="comment">//  - a(x) :- a21(x), a22(x).</span></div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;                <span class="comment">// Then, a(x) &lt;- (a11(x) ^ a12(x)) v (a21(x) ^ a22(x))</span></div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;                <span class="comment">//  =&gt; !a(x) &lt;- (!a11(x) v !a12(x)) ^ (!a21(x) v !a22(x))</span></div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;                <span class="comment">//  =&gt; !a(x) &lt;- (!a11(x) ^ !a21(x)) v (!a11(x) ^ !a22(x)) v ...</span></div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;                <span class="comment">// Essentially, produce every combination (m_1 ^ m_2 ^ ...) where m_i is a</span></div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;                <span class="comment">// negated literal in the ith rule of a.</span></div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;                addedBodyLiterals = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a8a7455cc2262cc907c15e6124ac6588a">formNegatedLiterals</a>(program, atom);</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;            }</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;        }</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;        <span class="keywordflow">if</span> (atomVersions.isValid()) {</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; curVec : atomVersions.getVector()) {</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span>* cur : curVec) {</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;                    <span class="keyword">delete</span> cur;</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;                }</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;            }</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;        }</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span>* constraint = dynamic_cast&lt;BinaryConstraint*&gt;(lit)) {</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;        NullableVector&lt;Argument*&gt; lhsVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a>(program, constraint-&gt;getLHS());</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;        <span class="keywordflow">if</span> (lhsVersions.isValid()) {</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;            changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;            <span class="keywordflow">for</span> (Argument* newLhs : lhsVersions.getVector()) {</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;                Literal* newLit = <span class="keyword">new</span> BinaryConstraint(constraint-&gt;getOperator(), Own&lt;Argument&gt;(newLhs),</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;                        <a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(constraint-&gt;getRHS()));</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;                versions.push_back(newLit);</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;            }</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;            NullableVector&lt;Argument*&gt; rhsVersions = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">getInlinedArgument</a>(program, constraint-&gt;getRHS());</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;            <span class="keywordflow">if</span> (rhsVersions.isValid()) {</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;                changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;                <span class="keywordflow">for</span> (Argument* newRhs : rhsVersions.getVector()) {</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;                    Literal* newLit = <span class="keyword">new</span> BinaryConstraint(constraint-&gt;getOperator(),</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;                            <a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(constraint-&gt;getLHS()), Own&lt;Argument&gt;(newRhs));</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;                    versions.push_back(newLit);</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;                }</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;            }</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;        }</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;    }</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;    <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;        <span class="comment">// Not inlined directly but found replacement literals</span></div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;        <span class="comment">// Rewrite these as single-literal bodies</span></div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;        <span class="keywordflow">for</span> (Literal* version : versions) {</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;            std::vector&lt;Literal*&gt; newBody;</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;            newBody.push_back(version);</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;            addedBodyLiterals.push_back(newBody);</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;        }</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;        inlined = <span class="keyword">true</span>;</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;    }</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;    <span class="keywordflow">if</span> (inlined) {</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::vector&lt;Literal*&gt;&gt;(addedBodyLiterals);</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::vector&lt;Literal*&gt;&gt;();</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;    }</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;}</div><div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_a3ce47150ce3942c816dc5d8286f3ee23"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23">souffle::ast::transform::inlineBodyLiterals</a></div><div class="ttdeci">std::pair&lt; NullableVector&lt; Literal * &gt;, std::vector&lt; BinaryConstraint * &gt; &gt; inlineBodyLiterals(Atom *atom, Clause *atomInlineClause)</div><div class="ttdoc">Inlines the given atom based on a given clause. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00295">InlineRelations.cpp:295</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_a8a7455cc2262cc907c15e6124ac6588a"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a8a7455cc2262cc907c15e6124ac6588a">souffle::ast::transform::formNegatedLiterals</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; Literal * &gt; &gt; formNegatedLiterals(Program &amp;program, Atom *atom)</div><div class="ttdoc">Forms the bodies that will replace the negation of a given inlined atom. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00431">InlineRelations.cpp:431</a></div></div>
<div class="ttc" id="namespacesouffle_html_a1dd578fbaf92e67ee52ebdd8cf364584"><div class="ttname"><a href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a></div><div class="ttdeci">auto clone(const std::vector&lt; A *&gt; &amp;xs)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00166">ContainerUtil.h:166</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_a60d908235c9c6d168bdfb2098b55090e"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e">souffle::ast::transform::getInlinedLiteral</a></div><div class="ttdeci">NullableVector&lt; std::vector&lt; Literal * &gt; &gt; getInlinedLiteral(Program &amp;, Literal *)</div><div class="ttdoc">Tries to perform a single step of inlining on the given literal. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00775">InlineRelations.cpp:775</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_html_af59ed6a7c649aec10999baea2f2c8b35"><div class="ttname"><a href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35">souffle::ast::getRelation</a></div><div class="ttdeci">Relation * getRelation(const Program &amp;program, const QualifiedName &amp;name)</div><div class="ttdoc">Returns the relation with the given name in the program. </div><div class="ttdef"><b>Definition:</b> <a href="_utils_8cpp_source.html#l00094">Utils.cpp:94</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_addbf430b3cb758d9345bb1ba0dd17efd"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd">souffle::ast::transform::getInlinedAtom</a></div><div class="ttdeci">NullableVector&lt; Atom * &gt; getInlinedAtom(Program &amp;program, Atom &amp;atom)</div><div class="ttdoc">Returns a vector of atoms that should replace the given atom after one step of inlining. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00719">InlineRelations.cpp:719</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_html_a4aa067ee069beebb52dff5ee7250fc5f"><div class="ttname"><a href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f">souffle::ast::getClauses</a></div><div class="ttdeci">std::vector&lt; Clause * &gt; getClauses(const Program &amp;program, const QualifiedName &amp;relationName)</div><div class="ttdoc">Returns a vector of clauses in the program describing the relation with the given name...</div><div class="ttdef"><b>Definition:</b> <a href="_utils_8cpp_source.html#l00070">Utils.cpp:70</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_ac78e04494a4e67eb9ae63a399c99d92f"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f">souffle::ast::transform::getInlinedArgument</a></div><div class="ttdeci">NullableVector&lt; Argument * &gt; getInlinedArgument(Program &amp;program, const Argument *arg)</div><div class="ttdoc">Returns a vector of arguments that should replace the given argument after one step of inlining...</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00534">InlineRelations.cpp:534</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_a60d908235c9c6d168bdfb2098b55090e_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_a60d908235c9c6d168bdfb2098b55090e_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_a60d908235c9c6d168bdfb2098b55090e_cgraph" id="namespacesouffle_1_1ast_1_1transform_a60d908235c9c6d168bdfb2098b55090e_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584" title="souffle::clone" alt="" coords="1229,749,1338,775"/>
<area shape="rect" id="node3" href="namespacesouffle_1_1ast_1_1transform.html#a8a7455cc2262cc907c15e6124ac6588a" title="Forms the bodies that will replace the negation of a given inlined atom. " alt="" coords="220,324,387,365"/>
<area shape="rect" id="node24" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="442,13,617,39"/>
<area shape="rect" id="node28" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35" title="Returns the relation with the given name in the program. " alt="" coords="441,63,617,90"/>
<area shape="rect" id="node31" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html#ab1413c473cb705a7ce19d8e2bafa2509" title="souffle::ast::transform\l::NullableVector::getVector" alt="" coords="672,224,867,265"/>
<area shape="rect" id="node32" href="namespacesouffle_1_1ast_1_1transform.html#a3ce47150ce3942c816dc5d8286f3ee23" title="Inlines the given atom based on a given clause. " alt="" coords="446,408,613,449"/>
<area shape="rect" id="node37" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html#a9603290d354fffc43865cb122b514abf" title="souffle::ast::transform\l::NullableVector::isValid" alt="" coords="681,549,857,591"/>
<area shape="rect" id="node38" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f" title="Returns a vector of arguments that should replace the given argument after one step of inlining..." alt="" coords="446,795,613,836"/>
<area shape="rect" id="node44" href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd" title="Returns a vector of atoms that should replace the given atom after one step of inlining. " alt="" coords="220,605,387,647"/>
<area shape="rect" id="node45" href="classsouffle_1_1ast_1_1_relation.html#a4f64acf8983db2fb8ba59c9273c1cf20" title="Check for a relation qualifier. " alt="" coords="226,1093,381,1135"/>
<area shape="rect" id="node4" href="namespacesouffle_1_1ast_1_1transform.html#a146c65e4e8a4429da50a66c746744e58" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="435,240,624,281"/>
<area shape="rect" id="node27" href="classsouffle_1_1ast_1_1_atom.html#ab9a22c7f862012f074559a4061696241" title="Return qualified name. " alt="" coords="455,576,603,617"/>
<area shape="rect" id="node5" href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d" title="Returns the negated version of a given literal. " alt="" coords="686,432,853,473"/>
<area shape="rect" id="node6" href="classsouffle_1_1ast_1_1_atom.html#a25ad407a2a6ec36e21062d70ff74b24b" title="Create a clone (i.e. " alt="" coords="953,531,1091,572"/>
<area shape="rect" id="node9" href="namespacesouffle_1_1ast.html#aa858fc1ad141e8a9dd2b806407c65116" title="Negate an ast constraint. " alt="" coords="915,363,1129,404"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a315141918c39611929a694840f046fb5" title="souffle::fatal" alt="" coords="1231,429,1335,455"/>
<area shape="rect" id="node7" href="classsouffle_1_1ast_1_1_atom.html#a62f0d1457357894e5553a98a9df0deaf" title="souffle::ast::Atom\l::Atom" alt="" coords="1215,531,1352,572"/>
<area shape="rect" id="node8" href="classsouffle_1_1ast_1_1_node.html#ac87a64ccec4ee0e470effeef0c6f3a0b" title="Return source location of the Node. " alt="" coords="1215,617,1351,659"/>
<area shape="rect" id="node23" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="1177,370,1389,397"/>
<area shape="rect" id="node11" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61" title="tinyformat::format" alt="" coords="1437,429,1580,455"/>
<area shape="rect" id="node12" href="namespacetinyformat.html#a86ed74eb3ed66a662e96220d877da964" title="Format list of arguments to the stream according to the given format string. " alt="" coords="1628,429,1779,455"/>
<area shape="rect" id="node20" href="namespacetinyformat.html#ab7b10973ec89e6601353675a85f99d61" title="tinyformat::makeFormatList" alt="" coords="1827,362,2032,389"/>
<area shape="rect" id="node13" href="namespacetinyformat_1_1detail.html#a9fe547bc617c38498e58c12cce507bec" title="tinyformat::detail\l::formatImpl" alt="" coords="1861,413,1997,455"/>
<area shape="rect" id="node21" href="namespacetinyformat.html#a970fd8292e14eb74ba55bafb41017016" title="tinyformat::printf" alt="" coords="1862,479,1997,506"/>
<area shape="rect" id="node22" href="namespacetinyformat.html#a97775445fea05ffaaa0690ab3bb1a920" title="tinyformat::printfln" alt="" coords="1857,530,2002,557"/>
<area shape="rect" id="node14" href="namespacetinyformat_1_1detail.html#ad3d636b9f85202b515c8940b7fcb62a6" title="tinyformat::detail\l::printFormatStringLiteral" alt="" coords="2081,348,2267,389"/>
<area shape="rect" id="node15" href="namespacetinyformat_1_1detail.html#ab4493739cbfe66bc79867f13f1fdf0db" title="tinyformat::detail\l::streamStateFromFormat" alt="" coords="2080,413,2268,455"/>
<area shape="rect" id="node19" href="classtinyformat_1_1detail_1_1_format_arg.html#acbf435711bbe4a4da7fc81758d7108a9" title="tinyformat::detail\l::FormatArg::format" alt="" coords="2099,479,2249,520"/>
<area shape="rect" id="node16" href="namespacetinyformat_1_1detail.html#a67285e0adb9f4164f9fc30a3eb11c771" title="tinyformat::detail\l::parseIntAndAdvance" alt="" coords="2543,384,2707,425"/>
<area shape="rect" id="node17" href="namespacetinyformat_1_1detail.html#ae1e94cbdd9e7cf26f17856a1792664e1" title="tinyformat::detail\l::parseWidthOrPrecision" alt="" coords="2316,443,2495,484"/>
<area shape="rect" id="node18" href="classtinyformat_1_1detail_1_1_format_arg.html#a91b69f66ce9dc8ca2914dce8985d7a1a" title="tinyformat::detail\l::FormatArg::toInt" alt="" coords="2557,449,2693,491"/>
<area shape="rect" id="node25" href="classsouffle_1_1ast_1_1_program.html#a529839d448f4139ce2e4e87bcfe3201f" title="Return clauses. " alt="" coords="943,5,1101,47"/>
<area shape="rect" id="node26" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1210,78,1357,105"/>
<area shape="rect" id="node29" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="717,114,821,141"/>
<area shape="rect" id="node30" href="classsouffle_1_1ast_1_1_program.html#a89bc64ed82fbb346ff8fcb922386c196" title="Return relations. " alt="" coords="943,71,1101,112"/>
<area shape="rect" id="node33" href="namespacesouffle_1_1ast_1_1transform.html#a4ef7394d84d020c597cb916fa67ff8ed" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="686,367,853,408"/>
<area shape="rect" id="node34" href="classsouffle_1_1ast_1_1_atom.html#a48b2afc7e3e22611a93b42f0089342d8" title="Return arguments. " alt="" coords="953,232,1091,273"/>
<area shape="rect" id="node35" href="namespacesouffle_1_1ast_1_1transform.html#aef0f3b772710ab151915d04c2538070e" title="Reduces a vector of substitutions. " alt="" coords="939,297,1105,339"/>
<area shape="rect" id="node36" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1" title="A generic factory for constraints of the form. " alt="" coords="1190,305,1377,331"/>
<area shape="rect" id="node39" href="namespacesouffle_1_1ast_1_1transform.html#ac08b034edc612cbd02a263082b1bbc46" title="souffle::ast::transform\l::combineAggregators" alt="" coords="686,976,853,1017"/>
<area shape="rect" id="node42" href="classsouffle_1_1ast_1_1_aggregator.html#a89b1301ec904219812c93d5eb62b2c3e" title="Set body. " alt="" coords="682,911,857,952"/>
<area shape="rect" id="node43" href="classsouffle_1_1ast_1_1_node.html#a8eab0e38c9a5343d641d5b2eb631733a" title="Set source location for the Node. " alt="" coords="701,845,837,887"/>
<area shape="rect" id="node40" href="namespacesouffle_1_1ast_1_1transform.html#a1211fcf1fa30273559973f585502c936" title="Renames all variables in a given argument uniquely. " alt="" coords="939,911,1105,952"/>
<area shape="rect" id="node41" href="classsouffle_1_1ast_1_1_node.html#a40bbdb53c63f664c2c43854dc7f0af7b" title="Apply the mapper to all child nodes. " alt="" coords="1215,911,1351,952"/>
</map>
</div>

</div>
</div>
<a id="a3ce47150ce3942c816dc5d8286f3ee23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce47150ce3942c816dc5d8286f3ee23">&#9670;&nbsp;</a></span>inlineBodyLiterals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt;<a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a>*&gt;, std::vector&lt;<a class="el" href="classsouffle_1_1ast_1_1_binary_constraint.html">BinaryConstraint</a>*&gt; &gt; souffle::ast::transform::inlineBodyLiterals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>atom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> *&#160;</td>
          <td class="paramname"><em>atomInlineClause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inlines the given atom based on a given clause. </p>
<p>Returns the vector of replacement literals and the necessary constraints. If unification is unsuccessful, the vector of literals is marked as invalid. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00295">295</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="_container_util_8h_source.html#l00166">souffle::clone()</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">souffle::EQ</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00075">souffle::ast::transform::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="_inline_relations_8cpp_source.html#l00071">souffle::ast::transform::NullableVector&lt; T &gt;::isValid()</a>, and <a class="el" href="_inline_relations_8cpp_source.html#l00269">unifyAtoms()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00431">formNegatedLiterals()</a>, and <a class="el" href="_inline_relations_8cpp_source.html#l00775">getInlinedLiteral()</a>.</p>
<div class="fragment"><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;                                              {</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    std::vector&lt;Literal*&gt; addedLits;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    std::vector&lt;BinaryConstraint*&gt; constraints;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    <span class="comment">// Rename the variables in the inlined clause to avoid conflicts when unifying multiple atoms</span></div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="comment">// - particularly when an inlined relation appears twice in a clause.</span></div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span> inlineCount = 0;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="comment">// Make a temporary clone so we can rename variables without fear</span></div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    <span class="keyword">auto</span> atomClause = <a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(atomInlineClause);</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <span class="keyword">struct </span>VariableRenamer : <span class="keyword">public</span> NodeMapper {</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        <span class="keywordtype">int</span> varnum;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        VariableRenamer(<span class="keywordtype">int</span> varnum) : varnum(varnum) {}</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        Own&lt;Node&gt; operator()(Own&lt;Node&gt; node)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = dynamic_cast&lt;ast::Variable*&gt;(node.get())) {</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                <span class="comment">// Rename the variable</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                <span class="keyword">auto</span> newVar = <a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(var);</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                std::stringstream newName;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                newName &lt;&lt; <span class="stringliteral">&quot;&lt;inlined_&quot;</span> &lt;&lt; var-&gt;getName() &lt;&lt; <span class="stringliteral">&quot;_&quot;</span> &lt;&lt; varnum &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                newVar-&gt;setName(newName.str());</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                <span class="keywordflow">return</span> newVar;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;            }</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;            <span class="keywordflow">return</span> node;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;        }</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    };</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    VariableRenamer update(inlineCount);</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    atomClause-&gt;apply(update);</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    inlineCount++;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    <span class="comment">// Get the constraints needed to unify the two atoms</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    NullableVector&lt;std::pair&lt;Argument*, Argument*&gt;&gt; res = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#a4ef7394d84d020c597cb916fa67ff8ed">unifyAtoms</a>(atomClause-&gt;getHead(), atom);</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="keywordflow">if</span> (res.isValid()) {</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        <span class="keywordflow">for</span> (std::pair&lt;Argument*, Argument*&gt; pair : res.getVector()) {</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;            <span class="comment">// FIXME: float equiv (`FEQ`)</span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;            constraints.push_back(<span class="keyword">new</span> BinaryConstraint(</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                    BinaryConstraintOp::EQ, <a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(pair.first), <a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(pair.second)));</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        }</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        <span class="comment">// Add in the body of the current clause of the inlined atom</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        <span class="keywordflow">for</span> (Literal* lit : atomClause-&gt;getBodyLiterals()) {</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;            addedLits.push_back(lit-&gt;clone());</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        }</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    }</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <span class="keywordflow">return</span> std::make_pair(NullableVector&lt;Literal*&gt;(addedLits), constraints);</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        <span class="keywordflow">return</span> std::make_pair(NullableVector&lt;Literal*&gt;(), constraints);</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    }</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a1dd578fbaf92e67ee52ebdd8cf364584"><div class="ttname"><a href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a></div><div class="ttdeci">auto clone(const std::vector&lt; A *&gt; &amp;xs)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00166">ContainerUtil.h:166</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_a4ef7394d84d020c597cb916fa67ff8ed"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#a4ef7394d84d020c597cb916fa67ff8ed">souffle::ast::transform::unifyAtoms</a></div><div class="ttdeci">NullableVector&lt; std::pair&lt; Argument *, Argument * &gt; &gt; unifyAtoms(Atom *first, Atom *second)</div><div class="ttdoc">Returns the nullable vector of substitutions needed to unify the two given atoms. ...</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00269">InlineRelations.cpp:269</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_a3ce47150ce3942c816dc5d8286f3ee23_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_a3ce47150ce3942c816dc5d8286f3ee23_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_a3ce47150ce3942c816dc5d8286f3ee23_cgraph" id="namespacesouffle_1_1ast_1_1transform_a3ce47150ce3942c816dc5d8286f3ee23_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584" title="souffle::clone" alt="" coords="1687,239,1797,266"/>
<area shape="rect" id="node3" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html#ab1413c473cb705a7ce19d8e2bafa2509" title="souffle::ast::transform\l::NullableVector::getVector" alt="" coords="220,656,415,697"/>
<area shape="rect" id="node33" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html#a9603290d354fffc43865cb122b514abf" title="souffle::ast::transform\l::NullableVector::isValid" alt="" coords="1149,707,1325,748"/>
<area shape="rect" id="node43" href="namespacesouffle_1_1ast_1_1transform.html#a4ef7394d84d020c597cb916fa67ff8ed" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="234,739,401,780"/>
<area shape="rect" id="node4" href="namespacesouffle_1_1ast_1_1transform.html#a60d908235c9c6d168bdfb2098b55090e" title="Tries to perform a single step of inlining on the given literal. " alt="" coords="463,551,629,592"/>
<area shape="rect" id="node5" href="namespacesouffle_1_1ast_1_1transform.html#a8a7455cc2262cc907c15e6124ac6588a" title="Forms the bodies that will replace the negation of a given inlined atom. " alt="" coords="687,821,854,863"/>
<area shape="rect" id="node26" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="919,493,1094,519"/>
<area shape="rect" id="node30" href="namespacesouffle_1_1ast.html#af59ed6a7c649aec10999baea2f2c8b35" title="Returns the relation with the given name in the program. " alt="" coords="919,543,1095,570"/>
<area shape="rect" id="node34" href="namespacesouffle_1_1ast_1_1transform.html#ac78e04494a4e67eb9ae63a399c99d92f" title="Returns a vector of arguments that should replace the given argument after one step of inlining..." alt="" coords="923,356,1090,397"/>
<area shape="rect" id="node40" href="namespacesouffle_1_1ast_1_1transform.html#addbf430b3cb758d9345bb1ba0dd17efd" title="Returns a vector of atoms that should replace the given atom after one step of inlining. " alt="" coords="687,696,854,737"/>
<area shape="rect" id="node42" href="classsouffle_1_1ast_1_1_relation.html#a4f64acf8983db2fb8ba59c9273c1cf20" title="Check for a relation qualifier. " alt="" coords="693,427,848,468"/>
<area shape="rect" id="node6" href="namespacesouffle_1_1ast_1_1transform.html#a146c65e4e8a4429da50a66c746744e58" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="912,1016,1101,1057"/>
<area shape="rect" id="node29" href="classsouffle_1_1ast_1_1_atom.html#ab9a22c7f862012f074559a4061696241" title="Return qualified name. " alt="" coords="933,829,1081,871"/>
<area shape="rect" id="node7" href="namespacesouffle_1_1ast_1_1transform.html#a940bd55ad10e760454fb7af87c1c130d" title="Returns the negated version of a given literal. " alt="" coords="1154,875,1321,916"/>
<area shape="rect" id="node8" href="classsouffle_1_1ast_1_1_atom.html#a25ad407a2a6ec36e21062d70ff74b24b" title="Create a clone (i.e. " alt="" coords="1412,736,1549,777"/>
<area shape="rect" id="node11" href="namespacesouffle_1_1ast.html#aa858fc1ad141e8a9dd2b806407c65116" title="Negate an ast constraint. " alt="" coords="1373,904,1588,945"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a315141918c39611929a694840f046fb5" title="souffle::fatal" alt="" coords="1690,853,1794,879"/>
<area shape="rect" id="node9" href="classsouffle_1_1ast_1_1_atom.html#a62f0d1457357894e5553a98a9df0deaf" title="souffle::ast::Atom\l::Atom" alt="" coords="1673,736,1811,777"/>
<area shape="rect" id="node10" href="classsouffle_1_1ast_1_1_node.html#ac87a64ccec4ee0e470effeef0c6f3a0b" title="Return source location of the Node. " alt="" coords="1674,648,1810,689"/>
<area shape="rect" id="node25" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="1636,911,1848,938"/>
<area shape="rect" id="node13" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61" title="tinyformat::format" alt="" coords="1896,853,2039,879"/>
<area shape="rect" id="node14" href="namespacetinyformat.html#a86ed74eb3ed66a662e96220d877da964" title="Format list of arguments to the stream according to the given format string. " alt="" coords="2087,853,2237,879"/>
<area shape="rect" id="node22" href="namespacetinyformat.html#ab7b10973ec89e6601353675a85f99d61" title="tinyformat::makeFormatList" alt="" coords="2285,786,2491,813"/>
<area shape="rect" id="node15" href="namespacetinyformat_1_1detail.html#a9fe547bc617c38498e58c12cce507bec" title="tinyformat::detail\l::formatImpl" alt="" coords="2320,837,2456,879"/>
<area shape="rect" id="node23" href="namespacetinyformat.html#a970fd8292e14eb74ba55bafb41017016" title="tinyformat::printf" alt="" coords="2321,903,2455,930"/>
<area shape="rect" id="node24" href="namespacetinyformat.html#a97775445fea05ffaaa0690ab3bb1a920" title="tinyformat::printfln" alt="" coords="2315,954,2461,981"/>
<area shape="rect" id="node16" href="namespacetinyformat_1_1detail.html#ad3d636b9f85202b515c8940b7fcb62a6" title="tinyformat::detail\l::printFormatStringLiteral" alt="" coords="2540,772,2725,813"/>
<area shape="rect" id="node17" href="namespacetinyformat_1_1detail.html#ab4493739cbfe66bc79867f13f1fdf0db" title="tinyformat::detail\l::streamStateFromFormat" alt="" coords="2539,837,2727,879"/>
<area shape="rect" id="node21" href="classtinyformat_1_1detail_1_1_format_arg.html#acbf435711bbe4a4da7fc81758d7108a9" title="tinyformat::detail\l::FormatArg::format" alt="" coords="2557,903,2708,944"/>
<area shape="rect" id="node18" href="namespacetinyformat_1_1detail.html#a67285e0adb9f4164f9fc30a3eb11c771" title="tinyformat::detail\l::parseIntAndAdvance" alt="" coords="3001,808,3165,849"/>
<area shape="rect" id="node19" href="namespacetinyformat_1_1detail.html#ae1e94cbdd9e7cf26f17856a1792664e1" title="tinyformat::detail\l::parseWidthOrPrecision" alt="" coords="2775,867,2953,908"/>
<area shape="rect" id="node20" href="classtinyformat_1_1detail_1_1_format_arg.html#a91b69f66ce9dc8ca2914dce8985d7a1a" title="tinyformat::detail\l::FormatArg::toInt" alt="" coords="3015,873,3151,915"/>
<area shape="rect" id="node27" href="classsouffle_1_1ast_1_1_program.html#a529839d448f4139ce2e4e87bcfe3201f" title="Return clauses. " alt="" coords="1159,473,1316,515"/>
<area shape="rect" id="node28" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1407,546,1554,573"/>
<area shape="rect" id="node31" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1185,655,1289,682"/>
<area shape="rect" id="node32" href="classsouffle_1_1ast_1_1_program.html#a89bc64ed82fbb346ff8fcb922386c196" title="Return relations. " alt="" coords="1159,539,1316,580"/>
<area shape="rect" id="node35" href="namespacesouffle_1_1ast_1_1transform.html#ac08b034edc612cbd02a263082b1bbc46" title="souffle::ast::transform\l::combineAggregators" alt="" coords="1154,173,1321,215"/>
<area shape="rect" id="node38" href="classsouffle_1_1ast_1_1_aggregator.html#a89b1301ec904219812c93d5eb62b2c3e" title="Set body. " alt="" coords="1150,356,1325,397"/>
<area shape="rect" id="node39" href="classsouffle_1_1ast_1_1_node.html#a8eab0e38c9a5343d641d5b2eb631733a" title="Set source location for the Node. " alt="" coords="1169,291,1305,332"/>
<area shape="rect" id="node36" href="namespacesouffle_1_1ast_1_1transform.html#a1211fcf1fa30273559973f585502c936" title="Renames all variables in a given argument uniquely. " alt="" coords="1397,5,1564,47"/>
<area shape="rect" id="node37" href="classsouffle_1_1ast_1_1_node.html#a40bbdb53c63f664c2c43854dc7f0af7b" title="Apply the mapper to all child nodes. " alt="" coords="1674,5,1810,47"/>
<area shape="rect" id="node41" href="classsouffle_1_1ast_1_1_atom.html#a48b2afc7e3e22611a93b42f0089342d8" title="Return arguments. " alt="" coords="938,764,1075,805"/>
<area shape="rect" id="node44" href="namespacesouffle_1_1ast_1_1transform.html#aef0f3b772710ab151915d04c2538070e" title="Reduces a vector of substitutions. " alt="" coords="463,899,629,940"/>
<area shape="rect" id="node45" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1" title="A generic factory for constraints of the form. " alt="" coords="677,906,864,933"/>
</map>
</div>

</div>
</div>
<a id="a357d4c2dfac82f7f140b6b03b00d3a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357d4c2dfac82f7f140b6b03b00d3a2c">&#9670;&nbsp;</a></span>makeInfoRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#a767cede450719b5b1633f12b038c7d61">Own</a>&lt;<a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a>&gt; souffle::ast::transform::makeInfoRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>originalClause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>originalClauseNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>translationUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_provenance_8cpp_source.html#l00072">72</a> of file <a class="el" href="_provenance_8cpp_source.html">Provenance.cpp</a>.</p>

<p class="reference">References <a class="el" href="_program_8cpp_source.html#l00054">souffle::ast::Program::addClause()</a>, <a class="el" href="_misc_util_8h_source.html#l00192">souffle::fatal()</a>, <a class="el" href="tinyformat_8h_source.html#l01089">tinyformat::format()</a>, <a class="el" href="_atom_8h_source.html#l00071">souffle::ast::Atom::getArguments()</a>, <a class="el" href="_clause_8h_source.html#l00073">souffle::ast::Clause::getBodyLiterals()</a>, <a class="el" href="_clause_8h_source.html#l00068">souffle::ast::Clause::getHead()</a>, <a class="el" href="ast_2_translation_unit_8h_source.html#l00078">souffle::ast::TranslationUnit::getProgram()</a>, <a class="el" href="_atom_8h_source.html#l00051">souffle::ast::Atom::getQualifiedName()</a>, <a class="el" href="json11_8h_source.html#l00663">i</a>, <a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9ea551b723eafd6a31d444fcb2f5920fbd3">souffle::INFO</a>, <a class="el" href="_stream_util_8h_source.html#l00149">souffle::join()</a>, <a class="el" href="_provenance_8cpp_source.html#l00062">makeRelationName()</a>, <a class="el" href="_binary_constraint_ops_8h_source.html#l00330">souffle::toBinaryConstraintSymbol()</a>, and <a class="el" href="_string_util_8h_source.html#l00228">souffle::toString()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_provenance_8cpp_source.html#l00267">souffle::ast::transform::ProvenanceTransformer::transformMaxHeight()</a>.</p>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                                                                                            {</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    QualifiedName name =</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#aae013df7b43e604d0cbe81322c8a11dc">makeRelationName</a>(originalClause.getHead()-&gt;getQualifiedName(), <span class="stringliteral">&quot;@info&quot;</span>, originalClauseNum);</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="comment">// initialise info relation</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keyword">auto</span> infoRelation = <span class="keyword">new</span> Relation();</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    infoRelation-&gt;setQualifiedName(name);</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="comment">// set qualifier to INFO_RELATION</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    infoRelation-&gt;setRepresentation(RelationRepresentation::INFO);</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="comment">// create new clause containing a single fact</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keyword">auto</span> infoClause = <span class="keyword">new</span> Clause();</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="keyword">auto</span> infoClauseHead = <span class="keyword">new</span> Atom();</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    infoClauseHead-&gt;setQualifiedName(name);</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="comment">// (darth_tytus): Can this be unsigned?</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    infoRelation-&gt;addAttribute(mk&lt;Attribute&gt;(<span class="stringliteral">&quot;clause_num&quot;</span>, QualifiedName(<span class="stringliteral">&quot;number&quot;</span>)));</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    infoClauseHead-&gt;addArgument(mk&lt;NumericConstant&gt;(originalClauseNum));</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <span class="comment">// add head relation as meta info</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    std::vector&lt;std::string&gt; headVariables;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="comment">// a method to stringify an Argument, translating functors and aggregates</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="comment">// keep a global counter of functor and aggregate numbers, which increment for each unique</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="comment">// functor/aggregate</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="keywordtype">int</span> functorNumber = 0;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keywordtype">int</span> aggregateNumber = 0;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="keyword">auto</span> getArgInfo = [&amp;](Argument* arg) -&gt; std::string {</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = dynamic_cast&lt;ast::Variable*&gt;(arg)) {</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(*var);</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span>* constant = dynamic_cast&lt;Constant*&gt;(arg)) {</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(*constant);</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        }</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="keywordflow">if</span> (isA&lt;UnnamedVariable&gt;(arg)) {</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        }</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        <span class="keywordflow">if</span> (isA&lt;Functor&gt;(arg)) {</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61">tfm::format</a>(<span class="stringliteral">&quot;functor_%d&quot;</span>, functorNumber++);</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        }</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="keywordflow">if</span> (isA&lt;Aggregator&gt;(arg)) {</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61">tfm::format</a>(<span class="stringliteral">&quot;agg_%d&quot;</span>, aggregateNumber++);</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        }</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <a class="code" href="namespacesouffle.html#a315141918c39611929a694840f046fb5">fatal</a>(<span class="stringliteral">&quot;Unhandled argument type&quot;</span>);</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    };</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="comment">// add head arguments</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; arg : originalClause.getHead()-&gt;getArguments()) {</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        headVariables.push_back(getArgInfo(arg));</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    }</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <span class="comment">// join variables in the head with commas</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    std::stringstream headVariableString;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    headVariableString &lt;&lt; <a class="code" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">join</a>(headVariables, <span class="stringliteral">&quot;,&quot;</span>);</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="comment">// add an attribute to infoRelation for the head of clause</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    infoRelation-&gt;addAttribute(mk&lt;Attribute&gt;(std::string(<span class="stringliteral">&quot;head_vars&quot;</span>), QualifiedName(<span class="stringliteral">&quot;symbol&quot;</span>)));</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    infoClauseHead-&gt;addArgument(mk&lt;StringConstant&gt;(<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(<a class="code" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">join</a>(headVariables, <span class="stringliteral">&quot;,&quot;</span>))));</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="comment">// visit all body literals and add to info clause head</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; originalClause.getBodyLiterals().size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        <span class="keyword">auto</span> lit = originalClause.getBodyLiterals()[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        <span class="keyword">const</span> Atom* atom = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <span class="keywordflow">if</span> (isA&lt;Atom&gt;(lit)) {</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;            atom = <span class="keyword">static_cast&lt;</span>Atom*<span class="keyword">&gt;</span>(lit);</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isA&lt;Negation&gt;(lit)) {</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            atom = <span class="keyword">static_cast&lt;</span>Negation*<span class="keyword">&gt;</span>(lit)-&gt;getAtom();</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isA&lt;ProvenanceNegation&gt;(lit)) {</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;            atom = <span class="keyword">static_cast&lt;</span>ProvenanceNegation*<span class="keyword">&gt;</span>(lit)-&gt;getAtom();</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        }</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        <span class="comment">// add an attribute for atoms and binary constraints</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        <span class="keywordflow">if</span> (atom != <span class="keyword">nullptr</span> || isA&lt;BinaryConstraint&gt;(lit)) {</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;            infoRelation-&gt;addAttribute(</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                    mk&lt;Attribute&gt;(std::string(<span class="stringliteral">&quot;rel_&quot;</span>) + std::to_string(<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>), QualifiedName(<span class="stringliteral">&quot;symbol&quot;</span>)));</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        }</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        <span class="keywordflow">if</span> (atom != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            std::string relName = <a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(atom-&gt;getQualifiedName());</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            <span class="comment">// for an atom, add its name and variables (converting aggregates to variables)</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            <span class="keywordflow">if</span> (isA&lt;Atom&gt;(lit)) {</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                std::string atomDescription = relName;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; arg : atom-&gt;getArguments()) {</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                    atomDescription.append(<span class="stringliteral">&quot;,&quot;</span> + getArgInfo(arg));</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                }</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                infoClauseHead-&gt;addArgument(mk&lt;StringConstant&gt;(atomDescription));</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                <span class="comment">// for a negation, add a marker with the relation name</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isA&lt;Negation&gt;(lit)) {</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                infoClauseHead-&gt;addArgument(mk&lt;StringConstant&gt;(<span class="stringliteral">&quot;!&quot;</span> + relName));</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;            }</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        }</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    }</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="comment">// visit all body constraints and add to info clause head</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; originalClause.getBodyLiterals().size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        <span class="keyword">auto</span> lit = originalClause.getBodyLiterals()[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">auto</span> con = dynamic_cast&lt;BinaryConstraint*&gt;(lit)) {</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            <span class="comment">// for a constraint, add the constraint symbol and LHS and RHS</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            std::string constraintDescription = <a class="code" href="namespacesouffle.html#a10525539360588d9c9048cb27f80d6ea">toBinaryConstraintSymbol</a>(con-&gt;getOperator());</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            constraintDescription.append(<span class="stringliteral">&quot;,&quot;</span> + getArgInfo(con-&gt;getLHS()));</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;            constraintDescription.append(<span class="stringliteral">&quot;,&quot;</span> + getArgInfo(con-&gt;getRHS()));</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            infoClauseHead-&gt;addArgument(mk&lt;StringConstant&gt;(constraintDescription));</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        }</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    }</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    infoRelation-&gt;addAttribute(mk&lt;Attribute&gt;(<span class="stringliteral">&quot;clause_repr&quot;</span>, QualifiedName(<span class="stringliteral">&quot;symbol&quot;</span>)));</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    infoClauseHead-&gt;addArgument(mk&lt;StringConstant&gt;(<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(originalClause)));</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="comment">// set clause head and add clause to info relation</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    infoClause-&gt;setHead(Own&lt;Atom&gt;(infoClauseHead));</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    Program&amp; program = translationUnit.getProgram();</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    program.addClause(Own&lt;Clause&gt;(infoClause));</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    <span class="keywordflow">return</span> Own&lt;Relation&gt;(infoRelation);</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a10525539360588d9c9048cb27f80d6ea"><div class="ttname"><a href="namespacesouffle.html#a10525539360588d9c9048cb27f80d6ea">souffle::toBinaryConstraintSymbol</a></div><div class="ttdeci">char const  * toBinaryConstraintSymbol(const BinaryConstraintOp op)</div><div class="ttdoc">Converts operator to its symbolic representation. </div><div class="ttdef"><b>Definition:</b> <a href="_binary_constraint_ops_8h_source.html#l00330">BinaryConstraintOps.h:330</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00663">json11.h:663</a></div></div>
<div class="ttc" id="namespacesouffle_html_aecc08c83ad9634fc515b7aa094702949"><div class="ttname"><a href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">souffle::toString</a></div><div class="ttdeci">const std::string &amp; toString(const std::string &amp;str)</div><div class="ttdoc">A generic function converting strings into strings (trivial case). </div><div class="ttdef"><b>Definition:</b> <a href="_string_util_8h_source.html#l00228">StringUtil.h:228</a></div></div>
<div class="ttc" id="namespacesouffle_html_abe4e3f19879707216a2758b03f4e2deb"><div class="ttname"><a href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">souffle::join</a></div><div class="ttdeci">detail::joined_sequence&lt; Iter, Printer &gt; join(const Iter &amp;a, const Iter &amp;b, const std::string &amp;sep, const Printer &amp;p)</div><div class="ttdoc">Creates an object to be forwarded to some output stream for printing sequences of elements interspers...</div><div class="ttdef"><b>Definition:</b> <a href="_stream_util_8h_source.html#l00149">StreamUtil.h:149</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_aae013df7b43e604d0cbe81322c8a11dc"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#aae013df7b43e604d0cbe81322c8a11dc">souffle::ast::transform::makeRelationName</a></div><div class="ttdeci">QualifiedName makeRelationName(const QualifiedName &amp;orig, const std::string &amp;type, int num=-1)</div><div class="ttdoc">Helper functions. </div><div class="ttdef"><b>Definition:</b> <a href="_provenance_8cpp_source.html#l00062">Provenance.cpp:62</a></div></div>
<div class="ttc" id="namespacetinyformat_html_adc3e74768f0e2204f9f9a726fc07ec61"><div class="ttname"><a href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61">tinyformat::format</a></div><div class="ttdeci">void format(std::ostream &amp;out, const char *fmt)</div><div class="ttdef"><b>Definition:</b> <a href="tinyformat_8h_source.html#l01089">tinyformat.h:1089</a></div></div>
<div class="ttc" id="namespacesouffle_html_a315141918c39611929a694840f046fb5"><div class="ttname"><a href="namespacesouffle.html#a315141918c39611929a694840f046fb5">souffle::fatal</a></div><div class="ttdeci">void fatal(const char *format, const Args &amp;... args)</div><div class="ttdef"><b>Definition:</b> <a href="_misc_util_8h_source.html#l00192">MiscUtil.h:192</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_a357d4c2dfac82f7f140b6b03b00d3a2c_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_a357d4c2dfac82f7f140b6b03b00d3a2c_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_a357d4c2dfac82f7f140b6b03b00d3a2c_cgraph" id="namespacesouffle_1_1ast_1_1transform_a357d4c2dfac82f7f140b6b03b00d3a2c_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1ast_1_1_program.html#a6e242189a740536f24b73c7d2440636a" title="Add a clause. " alt="" coords="239,5,397,47"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a315141918c39611929a694840f046fb5" title="souffle::fatal" alt="" coords="266,122,370,149"/>
<area shape="rect" id="node4" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61" title="tinyformat::format" alt="" coords="492,97,635,123"/>
<area shape="rect" id="node16" href="classsouffle_1_1ast_1_1_atom.html#a48b2afc7e3e22611a93b42f0089342d8" title="Return arguments. " alt="" coords="249,173,387,215"/>
<area shape="rect" id="node18" href="classsouffle_1_1ast_1_1_clause.html#a199bb0fc53e3f9980967d67b8dfb68a5" title="Obtains a copy of the internally maintained body literals. " alt="" coords="245,239,391,280"/>
<area shape="rect" id="node19" href="classsouffle_1_1ast_1_1_clause.html#a92a6ca9ea20fe63f074d597d81d07c08" title="Return the atom that represents the head of the clause. " alt="" coords="245,304,391,345"/>
<area shape="rect" id="node20" href="classsouffle_1_1ast_1_1_translation_unit.html#a8f0d6c64ddd338b8a9372a63d950b45c" title="Return the program. " alt="" coords="231,369,405,411"/>
<area shape="rect" id="node21" href="classsouffle_1_1ast_1_1_atom.html#ab9a22c7f862012f074559a4061696241" title="Return qualified name. " alt="" coords="244,435,392,476"/>
<area shape="rect" id="node22" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="269,501,367,527"/>
<area shape="rect" id="node23" href="namespacesouffle_1_1ast_1_1transform.html#aae013df7b43e604d0cbe81322c8a11dc" title="Helper functions. " alt="" coords="235,603,401,644"/>
<area shape="rect" id="node24" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949" title="A generic function converting strings into strings (trivial case). " alt="" coords="501,551,626,578"/>
<area shape="rect" id="node26" href="namespacesouffle.html#a10525539360588d9c9048cb27f80d6ea" title="Converts operator to its symbolic representation. " alt="" coords="220,668,416,709"/>
<area shape="rect" id="node5" href="namespacetinyformat.html#a86ed74eb3ed66a662e96220d877da964" title="Format list of arguments to the stream according to the given format string. " alt="" coords="711,97,861,123"/>
<area shape="rect" id="node13" href="namespacetinyformat.html#ab7b10973ec89e6601353675a85f99d61" title="tinyformat::makeFormatList" alt="" coords="909,30,1115,57"/>
<area shape="rect" id="node6" href="namespacetinyformat_1_1detail.html#a9fe547bc617c38498e58c12cce507bec" title="tinyformat::detail\l::formatImpl" alt="" coords="944,81,1080,123"/>
<area shape="rect" id="node14" href="namespacetinyformat.html#a970fd8292e14eb74ba55bafb41017016" title="tinyformat::printf" alt="" coords="945,147,1079,174"/>
<area shape="rect" id="node15" href="namespacetinyformat.html#a97775445fea05ffaaa0690ab3bb1a920" title="tinyformat::printfln" alt="" coords="939,198,1085,225"/>
<area shape="rect" id="node7" href="namespacetinyformat_1_1detail.html#ad3d636b9f85202b515c8940b7fcb62a6" title="tinyformat::detail\l::printFormatStringLiteral" alt="" coords="1164,16,1349,57"/>
<area shape="rect" id="node8" href="namespacetinyformat_1_1detail.html#ab4493739cbfe66bc79867f13f1fdf0db" title="tinyformat::detail\l::streamStateFromFormat" alt="" coords="1163,81,1351,123"/>
<area shape="rect" id="node12" href="classtinyformat_1_1detail_1_1_format_arg.html#acbf435711bbe4a4da7fc81758d7108a9" title="tinyformat::detail\l::FormatArg::format" alt="" coords="1181,147,1332,188"/>
<area shape="rect" id="node9" href="namespacetinyformat_1_1detail.html#a67285e0adb9f4164f9fc30a3eb11c771" title="tinyformat::detail\l::parseIntAndAdvance" alt="" coords="1625,52,1789,93"/>
<area shape="rect" id="node10" href="namespacetinyformat_1_1detail.html#ae1e94cbdd9e7cf26f17856a1792664e1" title="tinyformat::detail\l::parseWidthOrPrecision" alt="" coords="1399,111,1577,152"/>
<area shape="rect" id="node11" href="classtinyformat_1_1detail_1_1_format_arg.html#a91b69f66ce9dc8ca2914dce8985d7a1a" title="tinyformat::detail\l::FormatArg::toInt" alt="" coords="1639,117,1775,159"/>
<area shape="rect" id="node17" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="490,214,637,241"/>
<area shape="rect" id="node25" href="classsouffle_1_1ast_1_1_qualified_name.html#a2196d7ab8b2fcaf081de81803351f7ed" title="append qualifiers " alt="" coords="464,603,663,644"/>
</map>
</div>

</div>
</div>
<a id="aae013df7b43e604d0cbe81322c8a11dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae013df7b43e604d0cbe81322c8a11dc">&#9670;&nbsp;</a></span>makeRelationName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1_qualified_name.html">QualifiedName</a> souffle::ast::transform::makeRelationName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_qualified_name.html">QualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper functions. </p>

<p class="definition">Definition at line <a class="el" href="_provenance_8cpp_source.html#l00062">62</a> of file <a class="el" href="_provenance_8cpp_source.html">Provenance.cpp</a>.</p>

<p class="reference">References <a class="el" href="_qualified_name_8h_source.html#l00045">souffle::ast::QualifiedName::append()</a>, and <a class="el" href="_string_util_8h_source.html#l00228">souffle::toString()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_provenance_8cpp_source.html#l00072">makeInfoRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;                                                                                                      {</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    QualifiedName newName(<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(orig));</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    newName.append(type);</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">if</span> (num != -1) {</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        newName.append((<span class="keyword">const</span> std::string&amp;)std::to_string(num));</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    }</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="keywordflow">return</span> newName;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_aecc08c83ad9634fc515b7aa094702949"><div class="ttname"><a href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">souffle::toString</a></div><div class="ttdeci">const std::string &amp; toString(const std::string &amp;str)</div><div class="ttdoc">A generic function converting strings into strings (trivial case). </div><div class="ttdef"><b>Definition:</b> <a href="_string_util_8h_source.html#l00228">StringUtil.h:228</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_aae013df7b43e604d0cbe81322c8a11dc_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_aae013df7b43e604d0cbe81322c8a11dc_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_aae013df7b43e604d0cbe81322c8a11dc_cgraph" id="namespacesouffle_1_1ast_1_1transform_aae013df7b43e604d0cbe81322c8a11dc_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1ast_1_1_qualified_name.html#a2196d7ab8b2fcaf081de81803351f7ed" title="append qualifiers " alt="" coords="220,5,419,47"/>
<area shape="rect" id="node3" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949" title="A generic function converting strings into strings (trivial case). " alt="" coords="257,71,382,98"/>
</map>
</div>

</div>
</div>
<a id="aa3fa526d9f8958b3b90d30e7b3502a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fa526d9f8958b3b90d30e7b3502a1f">&#9670;&nbsp;</a></span>nameInlinedUnderscores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::ast::transform::nameInlinedUnderscores </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all underscores in all atoms of inlined relations. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00141">141</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="ast_2_program_8h_source.html#l00133">souffle::ast::Program::apply()</a>, <a class="el" href="ast_2_program_8h_source.html#l00060">souffle::ast::Program::getRelations()</a>, and <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">souffle::INLINE</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00992">souffle::ast::transform::InlineRelationsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                                              {</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    <span class="keyword">struct </span>M : <span class="keyword">public</span> NodeMapper {</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        <span class="keyword">const</span> std::set&lt;QualifiedName&gt; inlinedRelations;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        <span class="keywordtype">bool</span> replaceUnderscores;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        M(std::set&lt;QualifiedName&gt; inlinedRelations, <span class="keywordtype">bool</span> replaceUnderscores)</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                : inlinedRelations(<a class="code" href="namespacestd.html">std</a>::move(inlinedRelations)), replaceUnderscores(replaceUnderscores) {}</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        Own&lt;Node&gt; operator()(Own&lt;Node&gt; node)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">int</span> underscoreCount = 0;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            <span class="keywordflow">if</span> (!replaceUnderscores) {</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                <span class="comment">// Check if we should start replacing underscores for this node&#39;s subnodes</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                <span class="keywordflow">if</span> (<span class="keyword">auto</span>* atom = dynamic_cast&lt;Atom*&gt;(node.get())) {</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                    <span class="keywordflow">if</span> (inlinedRelations.find(atom-&gt;getQualifiedName()) != inlinedRelations.end()) {</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                        <span class="comment">// Atom associated with an inlined relation, so replace the underscores</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;                        <span class="comment">// in all of its subnodes with named variables.</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                        M replace(inlinedRelations, <span class="keyword">true</span>);</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                        node-&gt;apply(replace);</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                        <span class="keywordflow">return</span> node;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                    }</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                }</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isA&lt;UnnamedVariable&gt;(node.get())) {</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                <span class="comment">// Give a unique name to the underscored variable</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                <span class="comment">// TODO (azreika): need a more consistent way of handling internally generated variables in</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                <span class="comment">// general</span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                std::stringstream newVarName;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                newVarName &lt;&lt; <span class="stringliteral">&quot;&lt;underscore_&quot;</span> &lt;&lt; underscoreCount++ &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                <span class="keywordflow">return</span> mk&lt;ast::Variable&gt;(newVarName.str());</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            }</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            <span class="keywordflow">return</span> node;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        }</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    };</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    <span class="comment">// Store the names of all relations to be inlined</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    std::set&lt;QualifiedName&gt; inlinedRelations;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="keywordflow">for</span> (Relation* rel : program.getRelations()) {</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        <span class="keywordflow">if</span> (rel-&gt;hasQualifier(RelationQualifier::INLINE)) {</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            inlinedRelations.insert(rel-&gt;getQualifiedName());</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        }</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    }</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <span class="comment">// Apply the renaming procedure to the entire program</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    M update(inlinedRelations, <span class="keyword">false</span>);</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    program.apply(update);</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;}</div><div class="ttc" id="namespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> <a href="_compiled_tuple_8h_source.html#l00172">CompiledTuple.h:172</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_aa3fa526d9f8958b3b90d30e7b3502a1f_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_aa3fa526d9f8958b3b90d30e7b3502a1f_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_aa3fa526d9f8958b3b90d30e7b3502a1f_cgraph" id="namespacesouffle_1_1ast_1_1transform_aa3fa526d9f8958b3b90d30e7b3502a1f_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1ast_1_1_program.html#ada52fa87a44d5fda0734645f0375b2bf" title="Apply the mapper to all child nodes. " alt="" coords="245,5,403,47"/>
<area shape="rect" id="node4" href="classsouffle_1_1ast_1_1_program.html#a89bc64ed82fbb346ff8fcb922386c196" title="Return relations. " alt="" coords="245,71,403,112"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a850ddc94302e9b170a98729a22a4c8fa" title="Applies a function to each element of a vector and returns the results. " alt="" coords="473,13,575,39"/>
<area shape="rect" id="node5" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="451,78,597,105"/>
</map>
</div>

</div>
</div>
<a id="a940bd55ad10e760454fb7af87c1c130d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940bd55ad10e760454fb7af87c1c130d">&#9670;&nbsp;</a></span>negateLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a>* souffle::ast::transform::negateLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> *&#160;</td>
          <td class="paramname"><em>lit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the negated version of a given literal. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00356">356</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="_atom_8h_source.html#l00075">souffle::ast::Atom::clone()</a>, <a class="el" href="_container_util_8h_source.html#l00166">souffle::clone()</a>, <a class="el" href="_misc_util_8h_source.html#l00192">souffle::fatal()</a>, and <a class="el" href="_utils_8cpp_source.html#l00284">souffle::ast::negateConstraintInPlace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00376">combineNegatedLiterals()</a>.</p>
<div class="fragment"><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                                     {</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span>* atom = dynamic_cast&lt;Atom*&gt;(lit)) {</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        <span class="keyword">auto</span>* neg = <span class="keyword">new</span> Negation(<a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(atom));</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;        <span class="keywordflow">return</span> neg;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span>* neg = dynamic_cast&lt;Negation*&gt;(lit)) {</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;        Atom* atom = neg-&gt;getAtom()-&gt;clone();</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        <span class="keywordflow">return</span> atom;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span>* cons = dynamic_cast&lt;Constraint*&gt;(lit)) {</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        Constraint* newCons = cons-&gt;clone();</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;        <a class="code" href="namespacesouffle_1_1ast.html#aa858fc1ad141e8a9dd2b806407c65116">negateConstraintInPlace</a>(*newCons);</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;        <span class="keywordflow">return</span> newCons;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    }</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    <a class="code" href="namespacesouffle.html#a315141918c39611929a694840f046fb5">fatal</a>(<span class="stringliteral">&quot;unsupported literal type: %s&quot;</span>, *lit);</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a1dd578fbaf92e67ee52ebdd8cf364584"><div class="ttname"><a href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a></div><div class="ttdeci">auto clone(const std::vector&lt; A *&gt; &amp;xs)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00166">ContainerUtil.h:166</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_html_aa858fc1ad141e8a9dd2b806407c65116"><div class="ttname"><a href="namespacesouffle_1_1ast.html#aa858fc1ad141e8a9dd2b806407c65116">souffle::ast::negateConstraintInPlace</a></div><div class="ttdeci">void negateConstraintInPlace(Constraint &amp;constraint)</div><div class="ttdoc">Negate an ast constraint. </div><div class="ttdef"><b>Definition:</b> <a href="_utils_8cpp_source.html#l00284">Utils.cpp:284</a></div></div>
<div class="ttc" id="namespacesouffle_html_a315141918c39611929a694840f046fb5"><div class="ttname"><a href="namespacesouffle.html#a315141918c39611929a694840f046fb5">souffle::fatal</a></div><div class="ttdeci">void fatal(const char *format, const Args &amp;... args)</div><div class="ttdef"><b>Definition:</b> <a href="_misc_util_8h_source.html#l00192">MiscUtil.h:192</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_a940bd55ad10e760454fb7af87c1c130d_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_a940bd55ad10e760454fb7af87c1c130d_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_a940bd55ad10e760454fb7af87c1c130d_cgraph" id="namespacesouffle_1_1ast_1_1transform_a940bd55ad10e760454fb7af87c1c130d_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1ast_1_1_atom.html#a25ad407a2a6ec36e21062d70ff74b24b" title="Create a clone (i.e. " alt="" coords="259,71,396,112"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584" title="souffle::clone" alt="" coords="534,137,643,163"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a315141918c39611929a694840f046fb5" title="souffle::fatal" alt="" coords="537,191,641,218"/>
<area shape="rect" id="node19" href="namespacesouffle_1_1ast.html#aa858fc1ad141e8a9dd2b806407c65116" title="Negate an ast constraint. " alt="" coords="220,239,435,280"/>
<area shape="rect" id="node3" href="classsouffle_1_1ast_1_1_atom.html#a62f0d1457357894e5553a98a9df0deaf" title="souffle::ast::Atom\l::Atom" alt="" coords="520,71,657,112"/>
<area shape="rect" id="node5" href="classsouffle_1_1ast_1_1_node.html#ac87a64ccec4ee0e470effeef0c6f3a0b" title="Return source location of the Node. " alt="" coords="521,5,657,47"/>
<area shape="rect" id="node7" href="namespacetinyformat.html#adc3e74768f0e2204f9f9a726fc07ec61" title="tinyformat::format" alt="" coords="743,191,885,218"/>
<area shape="rect" id="node8" href="namespacetinyformat.html#a86ed74eb3ed66a662e96220d877da964" title="Format list of arguments to the stream according to the given format string. " alt="" coords="933,191,1084,218"/>
<area shape="rect" id="node16" href="namespacetinyformat.html#ab7b10973ec89e6601353675a85f99d61" title="tinyformat::makeFormatList" alt="" coords="1132,125,1337,151"/>
<area shape="rect" id="node9" href="namespacetinyformat_1_1detail.html#a9fe547bc617c38498e58c12cce507bec" title="tinyformat::detail\l::formatImpl" alt="" coords="1167,176,1303,217"/>
<area shape="rect" id="node17" href="namespacetinyformat.html#a970fd8292e14eb74ba55bafb41017016" title="tinyformat::printf" alt="" coords="1167,242,1302,269"/>
<area shape="rect" id="node18" href="namespacetinyformat.html#a97775445fea05ffaaa0690ab3bb1a920" title="tinyformat::printfln" alt="" coords="1162,293,1307,319"/>
<area shape="rect" id="node10" href="namespacetinyformat_1_1detail.html#ad3d636b9f85202b515c8940b7fcb62a6" title="tinyformat::detail\l::printFormatStringLiteral" alt="" coords="1387,111,1572,152"/>
<area shape="rect" id="node11" href="namespacetinyformat_1_1detail.html#ab4493739cbfe66bc79867f13f1fdf0db" title="tinyformat::detail\l::streamStateFromFormat" alt="" coords="1385,176,1573,217"/>
<area shape="rect" id="node15" href="classtinyformat_1_1detail_1_1_format_arg.html#acbf435711bbe4a4da7fc81758d7108a9" title="tinyformat::detail\l::FormatArg::format" alt="" coords="1404,241,1555,283"/>
<area shape="rect" id="node12" href="namespacetinyformat_1_1detail.html#a67285e0adb9f4164f9fc30a3eb11c771" title="tinyformat::detail\l::parseIntAndAdvance" alt="" coords="1848,147,2012,188"/>
<area shape="rect" id="node13" href="namespacetinyformat_1_1detail.html#ae1e94cbdd9e7cf26f17856a1792664e1" title="tinyformat::detail\l::parseWidthOrPrecision" alt="" coords="1621,205,1800,247"/>
<area shape="rect" id="node14" href="classtinyformat_1_1detail_1_1_format_arg.html#a91b69f66ce9dc8ca2914dce8985d7a1a" title="tinyformat::detail\l::FormatArg::toInt" alt="" coords="1862,212,1998,253"/>
<area shape="rect" id="node20" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="483,246,695,273"/>
</map>
</div>

</div>
</div>
<a id="abe651d178e7c685164a511e9646ca475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe651d178e7c685164a511e9646ca475">&#9670;&nbsp;</a></span>normaliseInlinedHeads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::ast::transform::normaliseInlinedHeads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace constants in the head of inlined clauses with (constrained) variables. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00086">86</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="_program_8cpp_source.html#l00054">souffle::ast::Program::addClause()</a>, <a class="el" href="_container_util_8h_source.html#l00166">souffle::clone()</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">souffle::EQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa123e958001611b441dab45ff11ba98a">souffle::FEQ</a>, <a class="el" href="classsouffle_1_1ast_1_1_numeric_constant.html#a3ea71b542256a36d49a3e6cc54d72e3da22ae0e2b89e5e3d477f988cc36d3272b">souffle::ast::NumericConstant::Float</a>, <a class="el" href="_utils_8cpp_source.html#l00070">souffle::ast::getClauses()</a>, <a class="el" href="ast_2_program_8h_source.html#l00060">souffle::ast::Program::getRelations()</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">souffle::INLINE</a>, and <a class="el" href="_program_8cpp_source.html#l00060">souffle::ast::Program::removeClause()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00992">souffle::ast::transform::InlineRelationsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;                                             {</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span> newVarCount = 0;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="comment">// Go through the clauses of all inlined relations</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="keywordflow">for</span> (Relation* rel : program.getRelations()) {</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="keywordflow">if</span> (!rel-&gt;hasQualifier(RelationQualifier::INLINE)) {</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        }</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        <span class="keywordflow">for</span> (Clause* clause : <a class="code" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f">getClauses</a>(program, *rel)) {</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            <span class="comment">// Set up the new clause with an empty body and no arguments in the head</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            <span class="keyword">auto</span> newClause = mk&lt;Clause&gt;();</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            newClause-&gt;setSrcLoc(clause-&gt;getSrcLoc());</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            <span class="keyword">auto</span> clauseHead = mk&lt;Atom&gt;(clause-&gt;getHead()-&gt;getQualifiedName());</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;            <span class="comment">// Add in everything in the original body</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;            <span class="keywordflow">for</span> (Literal* lit : clause-&gt;getBodyLiterals()) {</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                newClause-&gt;addToBody(<a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(lit));</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            }</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            <span class="comment">// Set up the head arguments in the new clause</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;            <span class="keywordflow">for</span> (Argument* arg : clause-&gt;getHead()-&gt;getArguments()) {</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                <span class="keywordflow">if</span> (<span class="keyword">auto</span>* constant = dynamic_cast&lt;Constant*&gt;(arg)) {</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                    <span class="comment">// Found a constant in the head, so replace it with a variable</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                    std::stringstream newVar;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                    newVar &lt;&lt; <span class="stringliteral">&quot;&lt;new_var_&quot;</span> &lt;&lt; newVarCount++ &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                    clauseHead-&gt;addArgument(mk&lt;ast::Variable&gt;(newVar.str()));</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                    <span class="keyword">auto</span>* <span class="keyword">const</span> c_num = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>NumericConstant*<span class="keyword">&gt;</span>(constant);</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;                    assert((!c_num || c_num-&gt;getType()) &amp;&amp; <span class="stringliteral">&quot;numeric constant wasn&#39;t bound to a type&quot;</span>);</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                    <span class="keyword">auto</span> opEq = c_num &amp;&amp; *c_num-&gt;getType() == NumericConstant::Type::Float</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;                                        ? BinaryConstraintOp::FEQ</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                                        : BinaryConstraintOp::EQ;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;                    <span class="comment">// Add a body constraint to set the variable&#39;s value to be the original constant</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                    newClause-&gt;addToBody(mk&lt;BinaryConstraint&gt;(</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                            opEq, mk&lt;ast::Variable&gt;(newVar.str()), <a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(constant)));</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                    <span class="comment">// Already a variable</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                    clauseHead-&gt;addArgument(<a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(arg));</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;                }</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            }</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            newClause-&gt;setHead(std::move(clauseHead));</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            <span class="comment">// Replace the old clause with this one</span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;            program.addClause(std::move(newClause));</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            program.removeClause(clause);</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        }</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    }</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a1dd578fbaf92e67ee52ebdd8cf364584"><div class="ttname"><a href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a></div><div class="ttdeci">auto clone(const std::vector&lt; A *&gt; &amp;xs)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00166">ContainerUtil.h:166</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_html_a4aa067ee069beebb52dff5ee7250fc5f"><div class="ttname"><a href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f">souffle::ast::getClauses</a></div><div class="ttdeci">std::vector&lt; Clause * &gt; getClauses(const Program &amp;program, const QualifiedName &amp;relationName)</div><div class="ttdoc">Returns a vector of clauses in the program describing the relation with the given name...</div><div class="ttdef"><b>Definition:</b> <a href="_utils_8cpp_source.html#l00070">Utils.cpp:70</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_abe651d178e7c685164a511e9646ca475_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_abe651d178e7c685164a511e9646ca475_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_abe651d178e7c685164a511e9646ca475_cgraph" id="namespacesouffle_1_1ast_1_1transform_abe651d178e7c685164a511e9646ca475_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1ast_1_1_program.html#a6e242189a740536f24b73c7d2440636a" title="Add a clause. " alt="" coords="242,5,399,47"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584" title="souffle::clone" alt="" coords="266,71,375,98"/>
<area shape="rect" id="node4" href="namespacesouffle_1_1ast.html#a4aa067ee069beebb52dff5ee7250fc5f" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="233,122,408,149"/>
<area shape="rect" id="node7" href="classsouffle_1_1ast_1_1_program.html#a89bc64ed82fbb346ff8fcb922386c196" title="Return relations. " alt="" coords="456,172,613,213"/>
<area shape="rect" id="node8" href="classsouffle_1_1ast_1_1_program.html#a2d97408e345d7b58598a90f655eb49fd" title="Remove a clause. " alt="" coords="242,224,399,265"/>
<area shape="rect" id="node5" href="classsouffle_1_1ast_1_1_program.html#a529839d448f4139ce2e4e87bcfe3201f" title="Return clauses. " alt="" coords="456,107,613,148"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="661,147,808,174"/>
</map>
</div>

</div>
</div>
<a id="aef0f3b772710ab151915d04c2538070e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0f3b772710ab151915d04c2538070e">&#9670;&nbsp;</a></span>reduceSubstitution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::transform::reduceSubstitution </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *, <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces a vector of substitutions. </p>
<p>Returns false only if matched argument pairs are found to be incompatible. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00210">210</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="json11_8h_source.html#l00663">i</a>, <a class="el" href="_resolve_aliases_8cpp_source.html#l00169">lhs</a>, <a class="el" href="_resolve_aliases_8cpp_source.html#l00170">rhs</a>, and <a class="el" href="_constraint_system_8h_source.html#l00222">souffle::ast::analysis::sub()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00269">unifyAtoms()</a>.</p>
<div class="fragment"><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                                                                       {</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    <span class="comment">// Keep trying to reduce the substitutions until we reach a fixed point.</span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="comment">// Note that at this point no underscores (&#39;_&#39;) or counters (&#39;$&#39;) should appear.</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    <span class="keywordflow">while</span> (!done) {</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        done = <span class="keyword">true</span>;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <span class="comment">// Try reducing each pair by one step</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">sub</a>.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            <span class="keyword">auto</span> currPair = <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">sub</a>[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            Argument* <a class="code" href="_resolve_aliases_8cpp.html#aa40661b6cade2b7755921bda0bac0fb4">lhs</a> = currPair.first;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;            Argument* <a class="code" href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a> = currPair.second;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;            <span class="comment">// Start trying to reduce the substitution</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            <span class="comment">// Note: Can probably go further with this substitution reduction</span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;            <span class="keywordflow">if</span> (*lhs == *rhs) {</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                <span class="comment">// Get rid of redundant `x = x`</span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">sub</a>.erase(<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">sub</a>.begin() + <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>);</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                done = <span class="keyword">false</span>;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isA&lt;Constant&gt;(lhs) &amp;&amp; isA&lt;Constant&gt;(<a class="code" href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a>)) {</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                <span class="comment">// Both are constants but not equal (prev case =&gt; !=)</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;                <span class="comment">// Failed to unify!</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isA&lt;RecordInit&gt;(lhs) &amp;&amp; isA&lt;RecordInit&gt;(<a class="code" href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a>)) {</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                <span class="comment">// Note: we will not deal with the case where only one side is</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                <span class="comment">// a record and the other is a variable, as variables can be records</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;                <span class="comment">// on a deeper level.</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                std::vector&lt;Argument*&gt; lhsArgs = <span class="keyword">static_cast&lt;</span>RecordInit*<span class="keyword">&gt;</span>(<a class="code" href="_resolve_aliases_8cpp.html#aa40661b6cade2b7755921bda0bac0fb4">lhs</a>)-&gt;getArguments();</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                std::vector&lt;Argument*&gt; rhsArgs = <span class="keyword">static_cast&lt;</span>RecordInit*<span class="keyword">&gt;</span>(<a class="code" href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a>)-&gt;getArguments();</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                <span class="keywordflow">if</span> (lhsArgs.size() != rhsArgs.size()) {</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                    <span class="comment">// Records of unequal size can&#39;t be equated</span></div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                }</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                <span class="comment">// Equate all corresponding arguments</span></div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; lhsArgs.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                    <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">sub</a>.push_back(std::make_pair(lhsArgs[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>], rhsArgs[i]));</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                }</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                <span class="comment">// Get rid of the record equality</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">sub</a>.erase(<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">sub</a>.begin() + <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>);</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;                done = <span class="keyword">false</span>;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((isA&lt;RecordInit&gt;(lhs) &amp;&amp; isA&lt;Constant&gt;(rhs)) ||</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                       (isA&lt;Constant&gt;(<a class="code" href="_resolve_aliases_8cpp.html#aa40661b6cade2b7755921bda0bac0fb4">lhs</a>) &amp;&amp; isA&lt;RecordInit&gt;(rhs))) {</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                <span class="comment">// A record =/= a constant</span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            }</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        }</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    }</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00663">json11.h:663</a></div></div>
<div class="ttc" id="_resolve_aliases_8cpp_html_aa40661b6cade2b7755921bda0bac0fb4"><div class="ttname"><a href="_resolve_aliases_8cpp.html#aa40661b6cade2b7755921bda0bac0fb4">lhs</a></div><div class="ttdeci">Own&lt; Argument &gt; lhs</div><div class="ttdef"><b>Definition:</b> <a href="_resolve_aliases_8cpp_source.html#l00169">ResolveAliases.cpp:169</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1analysis_html_af454c8b25ece926ca5206774d8f23be1"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1">souffle::ast::analysis::sub</a></div><div class="ttdeci">std::shared_ptr&lt; Constraint&lt; Var &gt; &gt; sub(const Var &amp;a, const Var &amp;b, const std::string &amp;symbol=&quot;⊑&quot;)</div><div class="ttdoc">A generic factory for constraints of the form. </div><div class="ttdef"><b>Definition:</b> <a href="_constraint_system_8h_source.html#l00222">ConstraintSystem.h:222</a></div></div>
<div class="ttc" id="_resolve_aliases_8cpp_html_a4e09535c06791089b6e68d7af597db7a"><div class="ttname"><a href="_resolve_aliases_8cpp.html#a4e09535c06791089b6e68d7af597db7a">rhs</a></div><div class="ttdeci">Own&lt; Argument &gt; rhs</div><div class="ttdef"><b>Definition:</b> <a href="_resolve_aliases_8cpp_source.html#l00170">ResolveAliases.cpp:170</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_aef0f3b772710ab151915d04c2538070e_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_aef0f3b772710ab151915d04c2538070e_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_aef0f3b772710ab151915d04c2538070e_cgraph" id="namespacesouffle_1_1ast_1_1transform_aef0f3b772710ab151915d04c2538070e_cgraph">
<area shape="rect" id="node2" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1" title="A generic factory for constraints of the form. " alt="" coords="220,13,407,39"/>
</map>
</div>

</div>
</div>
<a id="a1211fcf1fa30273559973f585502c936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1211fcf1fa30273559973f585502c936">&#9670;&nbsp;</a></span>renameVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::ast::transform::renameVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renames all variables in a given argument uniquely. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00485">485</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="ast_2_node_8h_source.html#l00073">souffle::ast::Node::apply()</a>, and <a class="el" href="_container_util_8h_source.html#l00166">souffle::clone()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00512">combineAggregators()</a>.</p>
<div class="fragment"><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;                                    {</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span> varCount = 0;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    varCount++;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    <span class="keyword">struct </span>M : <span class="keyword">public</span> NodeMapper {</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;        <span class="keywordtype">int</span> varnum;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        M(<span class="keywordtype">int</span> varnum) : varnum(varnum) {}</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        Own&lt;Node&gt; operator()(Own&lt;Node&gt; node)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = dynamic_cast&lt;ast::Variable*&gt;(node.get())) {</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;                <span class="keyword">auto</span> newVar = <a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(var);</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;                std::stringstream newName;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;                newName &lt;&lt; var-&gt;getName() &lt;&lt; <span class="stringliteral">&quot;-v&quot;</span> &lt;&lt; varnum;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;                newVar-&gt;setName(newName.str());</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;                <span class="keywordflow">return</span> newVar;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            }</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;            <span class="keywordflow">return</span> node;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;        }</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    };</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    M update(varCount);</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    arg-&gt;apply(update);</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a1dd578fbaf92e67ee52ebdd8cf364584"><div class="ttname"><a href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a></div><div class="ttdeci">auto clone(const std::vector&lt; A *&gt; &amp;xs)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00166">ContainerUtil.h:166</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_a1211fcf1fa30273559973f585502c936_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_a1211fcf1fa30273559973f585502c936_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_a1211fcf1fa30273559973f585502c936_cgraph" id="namespacesouffle_1_1ast_1_1transform_a1211fcf1fa30273559973f585502c936_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1ast_1_1_node.html#a40bbdb53c63f664c2c43854dc7f0af7b" title="Apply the mapper to all child nodes. " alt="" coords="220,5,356,47"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584" title="souffle::clone" alt="" coords="233,71,343,98"/>
</map>
</div>

</div>
</div>
<a id="a00b86d43c262e724277436f7f829a4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b86d43c262e724277436f7f829a4fb">&#9670;&nbsp;</a></span>transformEqrelRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::ast::transform::transformEqrelRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_program.html">Program</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_relation.html">Relation</a> &amp;&#160;</td>
          <td class="paramname"><em>rel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform eqrel relations to explicitly define equivalence relations. </p>

<p class="definition">Definition at line <a class="el" href="_provenance_8cpp_source.html#l00197">197</a> of file <a class="el" href="_provenance_8cpp_source.html">Provenance.cpp</a>.</p>

<p class="reference">References <a class="el" href="_atom_8h_source.html#l00066">souffle::ast::Atom::addArgument()</a>, <a class="el" href="_program_8cpp_source.html#l00054">souffle::ast::Program::addClause()</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa26daa90bc6e4e7baf2b5781caef22940">souffle::BTREE</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa06a35dca93aeafc1b0f548410517223a">souffle::EQREL</a>, <a class="el" href="ast_2_relation_8h_source.html#l00067">souffle::ast::Relation::getArity()</a>, <a class="el" href="ast_2_relation_8h_source.html#l00051">souffle::ast::Relation::getQualifiedName()</a>, <a class="el" href="ast_2_relation_8h_source.html#l00097">souffle::ast::Relation::getRepresentation()</a>, <a class="el" href="_container_util_8h_source.html#l00152">souffle::map()</a>, and <a class="el" href="ast_2_relation_8h_source.html#l00102">souffle::ast::Relation::setRepresentation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_provenance_8cpp_source.html#l00267">souffle::ast::transform::ProvenanceTransformer::transformMaxHeight()</a>.</p>
<div class="fragment"><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                                                             {</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    assert(rel.getRepresentation() == RelationRepresentation::EQREL &amp;&amp;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            <span class="stringliteral">&quot;attempting to transform non-eqrel relation&quot;</span>);</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    assert(rel.getArity() == 2 &amp;&amp; <span class="stringliteral">&quot;eqrel relation not binary&quot;</span>);</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    rel.setRepresentation(RelationRepresentation::BTREE);</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="comment">// transitivity</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="comment">// transitive clause: A(x, z) :- A(x, y), A(y, z).</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    <span class="keyword">auto</span> transitiveClause = <span class="keyword">new</span> Clause();</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="keyword">auto</span> transitiveClauseHead = <span class="keyword">new</span> Atom(rel.getQualifiedName());</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    transitiveClauseHead-&gt;addArgument(mk&lt;ast::Variable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    transitiveClauseHead-&gt;addArgument(mk&lt;ast::Variable&gt;(<span class="stringliteral">&quot;z&quot;</span>));</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    <span class="keyword">auto</span> transitiveClauseBody = <span class="keyword">new</span> Atom(rel.getQualifiedName());</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    transitiveClauseBody-&gt;addArgument(mk&lt;ast::Variable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    transitiveClauseBody-&gt;addArgument(mk&lt;ast::Variable&gt;(<span class="stringliteral">&quot;y&quot;</span>));</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    <span class="keyword">auto</span> transitiveClauseBody2 = <span class="keyword">new</span> Atom(rel.getQualifiedName());</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    transitiveClauseBody2-&gt;addArgument(mk&lt;ast::Variable&gt;(<span class="stringliteral">&quot;y&quot;</span>));</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    transitiveClauseBody2-&gt;addArgument(mk&lt;ast::Variable&gt;(<span class="stringliteral">&quot;z&quot;</span>));</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    transitiveClause-&gt;setHead(Own&lt;Atom&gt;(transitiveClauseHead));</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    transitiveClause-&gt;addToBody(Own&lt;Literal&gt;(transitiveClauseBody));</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    transitiveClause-&gt;addToBody(Own&lt;Literal&gt;(transitiveClauseBody2));</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    program.addClause(Own&lt;Clause&gt;(transitiveClause));</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="comment">// symmetric</span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    <span class="comment">// symmetric clause: A(x, y) :- A(y, x).</span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    <span class="keyword">auto</span> symClause = <span class="keyword">new</span> Clause();</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <span class="keyword">auto</span> symClauseHead = <span class="keyword">new</span> Atom(rel.getQualifiedName());</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    symClauseHead-&gt;addArgument(mk&lt;ast::Variable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    symClauseHead-&gt;addArgument(mk&lt;ast::Variable&gt;(<span class="stringliteral">&quot;y&quot;</span>));</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="keyword">auto</span> symClauseBody = <span class="keyword">new</span> Atom(rel.getQualifiedName());</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    symClauseBody-&gt;addArgument(mk&lt;ast::Variable&gt;(<span class="stringliteral">&quot;y&quot;</span>));</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    symClauseBody-&gt;addArgument(mk&lt;ast::Variable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    symClause-&gt;setHead(Own&lt;Atom&gt;(symClauseHead));</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    symClause-&gt;addToBody(Own&lt;Literal&gt;(symClauseBody));</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    program.addClause(Own&lt;Clause&gt;(symClause));</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="comment">// reflexivity</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="comment">// reflexive clause: A(x, x) :- A(x, _).</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    <span class="keyword">auto</span> reflexiveClause = <span class="keyword">new</span> Clause();</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    <span class="keyword">auto</span> reflexiveClauseHead = <span class="keyword">new</span> Atom(rel.getQualifiedName());</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    reflexiveClauseHead-&gt;addArgument(mk&lt;ast::Variable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    reflexiveClauseHead-&gt;addArgument(mk&lt;ast::Variable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="keyword">auto</span> reflexiveClauseBody = <span class="keyword">new</span> Atom(rel.getQualifiedName());</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    reflexiveClauseBody-&gt;addArgument(mk&lt;ast::Variable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    reflexiveClauseBody-&gt;addArgument(mk&lt;UnnamedVariable&gt;());</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    reflexiveClause-&gt;setHead(Own&lt;Atom&gt;(reflexiveClauseHead));</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    reflexiveClause-&gt;addToBody(Own&lt;Literal&gt;(reflexiveClauseBody));</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    program.addClause(Own&lt;Clause&gt;(reflexiveClause));</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_a00b86d43c262e724277436f7f829a4fb_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_a00b86d43c262e724277436f7f829a4fb_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_a00b86d43c262e724277436f7f829a4fb_cgraph" id="namespacesouffle_1_1ast_1_1transform_a00b86d43c262e724277436f7f829a4fb_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1ast_1_1_atom.html#aa3bec9ba4999b03eec4d397b6573feba" title="Add argument to the atom. " alt="" coords="243,5,381,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1ast_1_1_program.html#a6e242189a740536f24b73c7d2440636a" title="Add a clause. " alt="" coords="233,71,391,112"/>
<area shape="rect" id="node4" href="classsouffle_1_1ast_1_1_relation.html#aa0ebaf146150082fce35101f164838ce" title="Return the arity of this relation. " alt="" coords="235,136,389,177"/>
<area shape="rect" id="node5" href="classsouffle_1_1ast_1_1_relation.html#aec7a180cc23c066453f1e97e9957ccfe" title="Get qualified relation name. " alt="" coords="235,201,389,243"/>
<area shape="rect" id="node6" href="classsouffle_1_1ast_1_1_relation.html#a450f02a680d04b6a448e4d8a105c32e3" title="Get relation representation. " alt="" coords="235,267,389,308"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a850ddc94302e9b170a98729a22a4c8fa" title="Applies a function to each element of a vector and returns the results. " alt="" coords="261,333,363,359"/>
<area shape="rect" id="node8" href="classsouffle_1_1ast_1_1_relation.html#aceaeeec993cac69992e661263c273e58" title="Set relation representation. " alt="" coords="235,384,389,425"/>
</map>
</div>

</div>
</div>
<a id="a4ef7394d84d020c597cb916fa67ff8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef7394d84d020c597cb916fa67ff8ed">&#9670;&nbsp;</a></span>unifyAtoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_nullable_vector.html">NullableVector</a>&lt;std::pair&lt;<a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a>*, <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a>*&gt; &gt; souffle::ast::transform::unifyAtoms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_atom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nullable vector of substitutions needed to unify the two given atoms. </p>
<p>If unification is not successful, the returned vector is marked as invalid. Assumes that the atoms are both of the same relation. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_8cpp_source.html#l00269">269</a> of file <a class="el" href="_inline_relations_8cpp_source.html">InlineRelations.cpp</a>.</p>

<p class="reference">References <a class="el" href="_atom_8h_source.html#l00071">souffle::ast::Atom::getArguments()</a>, <a class="el" href="json11_8h_source.html#l00663">i</a>, and <a class="el" href="_inline_relations_8cpp_source.html#l00210">reduceSubstitution()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_8cpp_source.html#l00295">inlineBodyLiterals()</a>.</p>
<div class="fragment"><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                                                                                    {</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    std::vector&lt;std::pair&lt;Argument*, Argument*&gt;&gt; substitution;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    std::vector&lt;Argument*&gt; firstArgs = first-&gt;getArguments();</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    std::vector&lt;Argument*&gt; secondArgs = second-&gt;getArguments();</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    <span class="comment">// Create the initial unification equalities</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; firstArgs.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        substitution.push_back(std::make_pair(firstArgs[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>], secondArgs[i]));</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    }</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    <span class="comment">// Reduce the substitutions</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    <span class="keywordtype">bool</span> success = <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#aef0f3b772710ab151915d04c2538070e">reduceSubstitution</a>(substitution);</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    <span class="keywordflow">if</span> (success) {</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::pair&lt;Argument*, Argument*&gt;&gt;(substitution);</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        <span class="comment">// Failed to unify the two atoms</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::pair&lt;Argument*, Argument*&gt;&gt;();</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    }</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00663">json11.h:663</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_aef0f3b772710ab151915d04c2538070e"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#aef0f3b772710ab151915d04c2538070e">souffle::ast::transform::reduceSubstitution</a></div><div class="ttdeci">bool reduceSubstitution(std::vector&lt; std::pair&lt; Argument *, Argument *&gt;&gt; &amp;sub)</div><div class="ttdoc">Reduces a vector of substitutions. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_8cpp_source.html#l00210">InlineRelations.cpp:210</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_a4ef7394d84d020c597cb916fa67ff8ed_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_a4ef7394d84d020c597cb916fa67ff8ed_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_a4ef7394d84d020c597cb916fa67ff8ed_cgraph" id="namespacesouffle_1_1ast_1_1transform_a4ef7394d84d020c597cb916fa67ff8ed_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1ast_1_1_atom.html#a48b2afc7e3e22611a93b42f0089342d8" title="Return arguments. " alt="" coords="235,5,372,47"/>
<area shape="rect" id="node4" href="namespacesouffle_1_1ast_1_1transform.html#aef0f3b772710ab151915d04c2538070e" title="Reduces a vector of substitutions. " alt="" coords="220,71,387,112"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="455,13,601,39"/>
<area shape="rect" id="node5" href="namespacesouffle_1_1ast_1_1analysis.html#af454c8b25ece926ca5206774d8f23be1" title="A generic factory for constraints of the form. " alt="" coords="435,78,621,105"/>
</map>
</div>

</div>
</div>
<a id="adaa9731f3b631defab0a7f237a9f1d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa9731f3b631defab0a7f237a9f1d19">&#9670;&nbsp;</a></span>usesInvalidWitness()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::vector&lt;<a class="el" href="classsouffle_1_1_src_location.html">SrcLocation</a>&gt; souffle::ast::transform::usesInvalidWitness </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsouffle_1_1ast_1_1_literal.html">Literal</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>literals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacesouffle.html#a767cede450719b5b1633f12b038c7d61">Own</a>&lt; <a class="el" href="classsouffle_1_1ast_1_1_argument.html">Argument</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>groundedArguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_semantic_checker_8cpp_source.html#l00824">824</a> of file <a class="el" href="_semantic_checker_8cpp_source.html">SemanticChecker.cpp</a>.</p>

<p class="reference">References <a class="el" href="_container_util_8h_source.html#l00166">souffle::clone()</a>, <a class="el" href="_aggregator_8h_source.html#l00067">souffle::ast::Aggregator::getBodyLiterals()</a>, <a class="el" href="_ground_8cpp_source.html#l00272">souffle::ast::analysis::getGroundedTerms()</a>, <a class="el" href="json11_8h_source.html#l00663">i</a>, <a class="el" href="json11_8h_source.html#l00662">str</a>, and <a class="el" href="ast_2utility_2_visitor_8h_source.html#l00267">souffle::ast::visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_semantic_checker_8cpp_source.html#l00945">souffle::ast::transform::SemanticCheckerImpl::checkWitnessProblem()</a>.</p>
<div class="fragment"><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;                                                                                             {</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;    <span class="comment">// Node-mapper that replaces aggregators with new (unique) variables</span></div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;    <span class="keyword">struct </span>M : <span class="keyword">public</span> NodeMapper {</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;        <span class="comment">// Variables introduced to replace aggregators</span></div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;        <span class="keyword">mutable</span> std::set&lt;std::string&gt; aggregatorVariables;</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;        <span class="keyword">const</span> std::set&lt;std::string&gt;&amp; getAggregatorVariables() {</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;            <span class="keywordflow">return</span> aggregatorVariables;</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;        }</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;        Own&lt;Node&gt; operator()(Own&lt;Node&gt; node)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">int</span> numReplaced = 0;</div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;            <span class="keywordflow">if</span> (isA&lt;Aggregator&gt;(node.get())) {</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;                <span class="comment">// Replace the aggregator with a variable</span></div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;                std::stringstream newVariableName;</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;                newVariableName &lt;&lt; <span class="stringliteral">&quot;+aggr_var_&quot;</span> &lt;&lt; numReplaced++;</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;                <span class="comment">// Keep track of which variables are bound to aggregators</span></div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;                aggregatorVariables.insert(newVariableName.str());</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;                <span class="keywordflow">return</span> mk&lt;ast::Variable&gt;(newVariableName.str());</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;            }</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;            <span class="keywordflow">return</span> node;</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;        }</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;    };</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;    std::vector&lt;SrcLocation&gt; result;</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;    <span class="comment">// Create two versions of the original clause</span></div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;    <span class="comment">// Clause 1 - will remain equivalent to the original clause in terms of variable groundedness</span></div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;    <span class="keyword">auto</span> originalClause = mk&lt;Clause&gt;();</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;    originalClause-&gt;setHead(mk&lt;Atom&gt;(<span class="stringliteral">&quot;*&quot;</span>));</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;    <span class="comment">// Clause 2 - will have aggregators replaced with intrinsically grounded variables</span></div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;    <span class="keyword">auto</span> aggregatorlessClause = mk&lt;Clause&gt;();</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;    aggregatorlessClause-&gt;setHead(mk&lt;Atom&gt;(<span class="stringliteral">&quot;*&quot;</span>));</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;    <span class="comment">// Construct both clauses in the same manner to match the original clause</span></div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;    <span class="comment">// Must keep track of the subnode in Clause 1 that each subnode in Clause 2 matches to</span></div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;    std::map&lt;const Argument*, const Argument*&gt; identicalSubnodeMap;</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Literal* lit : literals) {</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;        <span class="keyword">auto</span> firstClone = <a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(lit);</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;        <span class="keyword">auto</span> secondClone = <a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(lit);</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;        <span class="comment">// Construct the mapping between equivalent literal subnodes</span></div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;        std::vector&lt;const Argument*&gt; firstCloneArguments;</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;        <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(*firstClone, [&amp;](<span class="keyword">const</span> Argument&amp; arg) { firstCloneArguments.push_back(&amp;arg); });</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;        std::vector&lt;const Argument*&gt; secondCloneArguments;</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;        <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(*secondClone, [&amp;](<span class="keyword">const</span> Argument&amp; arg) { secondCloneArguments.push_back(&amp;arg); });</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; firstCloneArguments.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;            identicalSubnodeMap[secondCloneArguments[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]] = firstCloneArguments[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;        }</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;        <span class="comment">// Actually add the literal clones to each clause</span></div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;        originalClause-&gt;addToBody(std::move(firstClone));</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;        aggregatorlessClause-&gt;addToBody(std::move(secondClone));</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;    }</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;    <span class="comment">// Replace the aggregators in Clause 2 with variables</span></div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;    M update;</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;    aggregatorlessClause-&gt;apply(update);</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;    <span class="comment">// Create a dummy atom to force certain arguments to be grounded in the aggregatorlessClause</span></div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;    <span class="keyword">auto</span> groundingAtomAggregatorless = mk&lt;Atom&gt;(<span class="stringliteral">&quot;grounding_atom&quot;</span>);</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;    <span class="keyword">auto</span> groundingAtomOriginal = mk&lt;Atom&gt;(<span class="stringliteral">&quot;grounding_atom&quot;</span>);</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;    <span class="comment">// Force the new aggregator variables to be grounded in the aggregatorless clause</span></div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;    <span class="keyword">const</span> std::set&lt;std::string&gt;&amp; aggregatorVariables = update.getAggregatorVariables();</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::string&amp; <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a> : aggregatorVariables) {</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;        groundingAtomAggregatorless-&gt;addArgument(mk&lt;ast::Variable&gt;(<a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>));</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;    }</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;    <span class="comment">// Force the given grounded arguments to be grounded in both clauses</span></div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Own&lt;Argument&gt;&amp; arg : groundedArguments) {</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;        groundingAtomAggregatorless-&gt;addArgument(<a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(arg));</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;        groundingAtomOriginal-&gt;addArgument(<a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(arg));</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;    }</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;    aggregatorlessClause-&gt;addToBody(std::move(groundingAtomAggregatorless));</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;    originalClause-&gt;addToBody(std::move(groundingAtomOriginal));</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;    <span class="comment">// Compare the grounded analysis of both generated clauses</span></div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;    <span class="comment">// All added arguments in Clause 2 were forced to be grounded, so if an ungrounded argument</span></div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;    <span class="comment">// appears in Clause 2, it must also appear in Clause 1. Consequently, have two cases:</span></div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;    <span class="comment">//   - The argument is also ungrounded in Clause 1 - handled by another check</span></div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;    <span class="comment">//   - The argument is grounded in Clause 1 =&gt; the argument was grounded in the</span></div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    <span class="comment">//     first clause somewhere along the line by an aggregator-body - not allowed!</span></div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;    std::set&lt;Own&lt;Argument&gt;&gt; newlyGroundedArguments;</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;    <span class="keyword">auto</span> originalGrounded = <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a108a2d9570b44c655bf3165e8d8613d4">getGroundedTerms</a>(tu, *originalClause);</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; pair : <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a108a2d9570b44c655bf3165e8d8613d4">getGroundedTerms</a>(tu, *aggregatorlessClause)) {</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;        <span class="keywordflow">if</span> (!pair.second &amp;&amp; originalGrounded[identicalSubnodeMap[pair.first]]) {</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;            result.push_back(pair.first-&gt;getSrcLoc());</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;        }</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;        <span class="comment">// Otherwise, it can now be considered grounded</span></div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;        newlyGroundedArguments.insert(<a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(pair.first));</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;    }</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;    <span class="comment">// All previously grounded are still grounded</span></div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Own&lt;Argument&gt;&amp; arg : groundedArguments) {</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;        newlyGroundedArguments.insert(<a class="code" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a>(arg));</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;    }</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;    <span class="comment">// Everything on this level is fine, check subaggregators of each literal</span></div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Literal* lit : literals) {</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;        <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(*lit, [&amp;](<span class="keyword">const</span> Aggregator&amp; aggr) {</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;            <span class="comment">// Check recursively if an invalid witness is used</span></div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; argloc : <a class="code" href="namespacesouffle_1_1ast_1_1transform.html#adaa9731f3b631defab0a7f237a9f1d19">usesInvalidWitness</a>(tu, aggr.getBodyLiterals(), newlyGroundedArguments)) {</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;                result.push_back(argloc);</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;            }</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;        });</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;    }</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;    <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a1dd578fbaf92e67ee52ebdd8cf364584"><div class="ttname"><a href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584">souffle::clone</a></div><div class="ttdeci">auto clone(const std::vector&lt; A *&gt; &amp;xs)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00166">ContainerUtil.h:166</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1transform_html_adaa9731f3b631defab0a7f237a9f1d19"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1transform.html#adaa9731f3b631defab0a7f237a9f1d19">souffle::ast::transform::usesInvalidWitness</a></div><div class="ttdeci">static const std::vector&lt; SrcLocation &gt; usesInvalidWitness(TranslationUnit &amp;tu, const std::vector&lt; Literal *&gt; &amp;literals, const std::set&lt; Own&lt; Argument &gt;&gt; &amp;groundedArguments)</div><div class="ttdef"><b>Definition:</b> <a href="_semantic_checker_8cpp_source.html#l00824">SemanticChecker.cpp:824</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00663">json11.h:663</a></div></div>
<div class="ttc" id="json11_8h_html_a25fda444d34d64acade61be6f9d35367"><div class="ttname"><a href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a></div><div class="ttdeci">const std::string &amp; str</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00662">json11.h:662</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_1_1analysis_html_a108a2d9570b44c655bf3165e8d8613d4"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a108a2d9570b44c655bf3165e8d8613d4">souffle::ast::analysis::getGroundedTerms</a></div><div class="ttdeci">std::map&lt; const Argument *, bool &gt; getGroundedTerms(const TranslationUnit &amp;tu, const Clause &amp;clause)</div><div class="ttdoc">Analyse the given clause and computes for each contained argument whether it is a grounded value or n...</div><div class="ttdef"><b>Definition:</b> <a href="_ground_8cpp_source.html#l00272">Ground.cpp:272</a></div></div>
<div class="ttc" id="namespacesouffle_1_1ast_html_a0bf6b9bdf0a8866bd27dde18442ab43d"><div class="ttname"><a href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">souffle::ast::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const Node &amp;root, Visitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="ast_2utility_2_visitor_8h_source.html#l00267">Visitor.h:267</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_1_1ast_1_1transform_adaa9731f3b631defab0a7f237a9f1d19_cgraph.png" border="0" usemap="#namespacesouffle_1_1ast_1_1transform_adaa9731f3b631defab0a7f237a9f1d19_cgraph" alt=""/></div>
<map name="namespacesouffle_1_1ast_1_1transform_adaa9731f3b631defab0a7f237a9f1d19_cgraph" id="namespacesouffle_1_1ast_1_1transform_adaa9731f3b631defab0a7f237a9f1d19_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a1dd578fbaf92e67ee52ebdd8cf364584" title="souffle::clone" alt="" coords="253,5,362,32"/>
<area shape="rect" id="node3" href="classsouffle_1_1ast_1_1_aggregator.html#a4758136de8c11c3a217a06a7f464c053" title="Return body literals. " alt="" coords="220,57,395,98"/>
<area shape="rect" id="node5" href="namespacesouffle_1_1ast_1_1analysis.html#a108a2d9570b44c655bf3165e8d8613d4" title="Analyse the given clause and computes for each contained argument whether it is a grounded value or n..." alt="" coords="229,122,385,163"/>
<area shape="rect" id="node6" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="223,187,392,229"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="454,64,601,91"/>
<area shape="rect" id="node7" href="namespacesouffle_1_1ast.html#a5a45867d4cbfd053ffd30af4b4e1dd9e" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="443,187,612,229"/>
<area shape="rect" id="node8" href="classsouffle_1_1ast_1_1_node.html#a332720bacd0c374ab8ff3977f0d00210" title="Obtain a list of all embedded AST child nodes. " alt="" coords="660,187,796,229"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
